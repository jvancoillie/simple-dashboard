(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~js/admin"],{

/***/ "./node_modules/pickadate-webpack/lib/picker.date.js":
/*!***********************************************************!*\
  !*** ./node_modules/pickadate-webpack/lib/picker.date.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Date picker for pickadate.js v3.5.6\n * http://amsul.github.io/pickadate.js/date.htm\n */\n\n(function ( factory ) {\n\n    // Node.js/browserify.\n    if ( true )\n        module.exports = factory( __webpack_require__(/*! ./picker.js */ \"./node_modules/pickadate-webpack/lib/picker.js\"), __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\") )\n\n    // Browser globals.\n    else {}\n\n}(function( Picker, $ ) {\n\n\n/**\n * Globals and constants\n */\nvar DAYS_IN_WEEK = 7,\n    WEEKS_IN_CALENDAR = 6,\n    _ = Picker._\n\n\n\n/**\n * The date picker constructor\n */\nfunction DatePicker( picker, settings ) {\n\n    var calendar = this,\n        element = picker.$node[ 0 ],\n        elementValue = element.value,\n        elementDataValue = picker.$node.data( 'value' ),\n        valueString = elementDataValue || elementValue,\n        formatString = elementDataValue ? settings.formatSubmit : settings.format,\n        isRTL = function() {\n\n            return element.currentStyle ?\n\n                // For IE.\n                element.currentStyle.direction == 'rtl' :\n\n                // For normal browsers.\n                getComputedStyle( picker.$root[0] ).direction == 'rtl'\n        }\n\n    calendar.settings = settings\n    calendar.$node = picker.$node\n\n    // The queue of methods that will be used to build item objects.\n    calendar.queue = {\n        min: 'measure create',\n        max: 'measure create',\n        now: 'now create',\n        select: 'parse create validate',\n        highlight: 'parse navigate create validate',\n        view: 'parse create validate viewset',\n        disable: 'deactivate',\n        enable: 'activate'\n    }\n\n    // The component's item object.\n    calendar.item = {}\n\n    calendar.item.clear = null\n    calendar.item.disable = ( settings.disable || [] ).slice( 0 )\n    calendar.item.enable = -(function( collectionDisabled ) {\n        return collectionDisabled[ 0 ] === true ? collectionDisabled.shift() : -1\n    })( calendar.item.disable )\n\n    calendar.\n        set( 'min', settings.min ).\n        set( 'max', settings.max ).\n        set( 'now' )\n\n    // When there’s a value, set the `select`, which in turn\n    // also sets the `highlight` and `view`.\n    if ( valueString ) {\n        calendar.set( 'select', valueString, {\n            format: formatString,\n            defaultValue: true\n        })\n    }\n\n    // If there’s no value, default to highlighting “today”.\n    else {\n        calendar.\n            set( 'select', null ).\n            set( 'highlight', calendar.item.now )\n    }\n\n\n    // The keycode to movement mapping.\n    calendar.key = {\n        40: 7, // Down\n        38: -7, // Up\n        39: function() { return isRTL() ? -1 : 1 }, // Right\n        37: function() { return isRTL() ? 1 : -1 }, // Left\n        go: function( timeChange ) {\n            var highlightedObject = calendar.item.highlight,\n                targetDate = new Date( highlightedObject.year, highlightedObject.month, highlightedObject.date + timeChange )\n            calendar.set(\n                'highlight',\n                targetDate,\n                { interval: timeChange }\n            )\n            this.render()\n        }\n    }\n\n\n    // Bind some picker events.\n    picker.\n        on( 'render', function() {\n            picker.$root.find( '.' + settings.klass.selectMonth ).on( 'change', function() {\n                var value = this.value\n                if ( value ) {\n                    picker.set( 'highlight', [ picker.get( 'view' ).year, value, picker.get( 'highlight' ).date ] )\n                    picker.$root.find( '.' + settings.klass.selectMonth ).trigger( 'focus' )\n                }\n            })\n            picker.$root.find( '.' + settings.klass.selectYear ).on( 'change', function() {\n                var value = this.value\n                if ( value ) {\n                    picker.set( 'highlight', [ value, picker.get( 'view' ).month, picker.get( 'highlight' ).date ] )\n                    picker.$root.find( '.' + settings.klass.selectYear ).trigger( 'focus' )\n                }\n            })\n        }, 1 ).\n        on( 'open', function() {\n            var includeToday = ''\n            if ( calendar.disabled( calendar.get('now') ) ) {\n                includeToday = ':not(.' + settings.klass.buttonToday + ')'\n            }\n            picker.$root.find( 'button' + includeToday + ', select' ).attr( 'disabled', false )\n        }, 1 ).\n        on( 'close', function() {\n            picker.$root.find( 'button, select' ).attr( 'disabled', true )\n        }, 1 )\n\n} //DatePicker\n\n\n/**\n * Set a datepicker item object.\n */\nDatePicker.prototype.set = function( type, value, options ) {\n\n    var calendar = this,\n        calendarItem = calendar.item\n\n    // If the value is `null` just set it immediately.\n    if ( value === null ) {\n        if ( type == 'clear' ) type = 'select'\n        calendarItem[ type ] = value\n        return calendar\n    }\n\n    // Otherwise go through the queue of methods, and invoke the functions.\n    // Update this as the time unit, and set the final value as this item.\n    // * In the case of `enable`, keep the queue but set `disable` instead.\n    //   And in the case of `flip`, keep the queue but set `enable` instead.\n    calendarItem[ ( type == 'enable' ? 'disable' : type == 'flip' ? 'enable' : type ) ] = calendar.queue[ type ].split( ' ' ).map( function( method ) {\n        value = calendar[ method ]( type, value, options )\n        return value\n    }).pop()\n\n    // Check if we need to cascade through more updates.\n    if ( type == 'select' ) {\n        calendar.set( 'highlight', calendarItem.select, options )\n    }\n    else if ( type == 'highlight' ) {\n        calendar.set( 'view', calendarItem.highlight, options )\n    }\n    else if ( type.match( /^(flip|min|max|disable|enable)$/ ) ) {\n        if ( calendarItem.select && calendar.disabled( calendarItem.select ) ) {\n            calendar.set( 'select', calendarItem.select, options )\n        }\n        if ( calendarItem.highlight && calendar.disabled( calendarItem.highlight ) ) {\n            calendar.set( 'highlight', calendarItem.highlight, options )\n        }\n    }\n\n    return calendar\n} //DatePicker.prototype.set\n\n\n/**\n * Get a datepicker item object.\n */\nDatePicker.prototype.get = function( type ) {\n    return this.item[ type ]\n} //DatePicker.prototype.get\n\n\n/**\n * Create a picker date object.\n */\nDatePicker.prototype.create = function( type, value, options ) {\n\n    var isInfiniteValue,\n        calendar = this\n\n    // If there’s no value, use the type as the value.\n    value = value === undefined ? type : value\n\n\n    // If it’s infinity, update the value.\n    if ( value == -Infinity || value == Infinity ) {\n        isInfiniteValue = value\n    }\n\n    // If it’s an object, use the native date object.\n    else if ( $.isPlainObject( value ) && _.isInteger( value.pick ) ) {\n        value = value.obj\n    }\n\n    // If it’s an array, convert it into a date and make sure\n    // that it’s a valid date – otherwise default to today.\n    else if ( $.isArray( value ) ) {\n        value = new Date( value[ 0 ], value[ 1 ], value[ 2 ] )\n        value = _.isDate( value ) ? value : calendar.create().obj\n    }\n\n    // If it’s a number or date object, make a normalized date.\n    else if ( _.isInteger( value ) || _.isDate( value ) ) {\n        value = calendar.normalize( new Date( value ), options )\n    }\n\n    // If it’s a literal true or any other case, set it to now.\n    else /*if ( value === true )*/ {\n        value = calendar.now( type, value, options )\n    }\n\n    // Return the compiled object.\n    return {\n        year: isInfiniteValue || value.getFullYear(),\n        month: isInfiniteValue || value.getMonth(),\n        date: isInfiniteValue || value.getDate(),\n        day: isInfiniteValue || value.getDay(),\n        obj: isInfiniteValue || value,\n        pick: isInfiniteValue || value.getTime()\n    }\n} //DatePicker.prototype.create\n\n\n/**\n * Create a range limit object using an array, date object,\n * literal “true”, or integer relative to another time.\n */\nDatePicker.prototype.createRange = function( from, to ) {\n\n    var calendar = this,\n        createDate = function( date ) {\n            if ( date === true || $.isArray( date ) || _.isDate( date ) ) {\n                return calendar.create( date )\n            }\n            return date\n        }\n\n    // Create objects if possible.\n    if ( !_.isInteger( from ) ) {\n        from = createDate( from )\n    }\n    if ( !_.isInteger( to ) ) {\n        to = createDate( to )\n    }\n\n    // Create relative dates.\n    if ( _.isInteger( from ) && $.isPlainObject( to ) ) {\n        from = [ to.year, to.month, to.date + from ];\n    }\n    else if ( _.isInteger( to ) && $.isPlainObject( from ) ) {\n        to = [ from.year, from.month, from.date + to ];\n    }\n\n    return {\n        from: createDate( from ),\n        to: createDate( to )\n    }\n} //DatePicker.prototype.createRange\n\n\n/**\n * Check if a date unit falls within a date range object.\n */\nDatePicker.prototype.withinRange = function( range, dateUnit ) {\n    range = this.createRange(range.from, range.to)\n    return dateUnit.pick >= range.from.pick && dateUnit.pick <= range.to.pick\n}\n\n\n/**\n * Check if two date range objects overlap.\n */\nDatePicker.prototype.overlapRanges = function( one, two ) {\n\n    var calendar = this\n\n    // Convert the ranges into comparable dates.\n    one = calendar.createRange( one.from, one.to )\n    two = calendar.createRange( two.from, two.to )\n\n    return calendar.withinRange( one, two.from ) || calendar.withinRange( one, two.to ) ||\n        calendar.withinRange( two, one.from ) || calendar.withinRange( two, one.to )\n}\n\n\n/**\n * Get the date today.\n */\nDatePicker.prototype.now = function( type, value, options ) {\n    value = new Date()\n    if ( options && options.rel ) {\n        value.setDate( value.getDate() + options.rel )\n    }\n    return this.normalize( value, options )\n}\n\n\n/**\n * Navigate to next/prev month.\n */\nDatePicker.prototype.navigate = function( type, value, options ) {\n\n    var targetDateObject,\n        targetYear,\n        targetMonth,\n        targetDate,\n        isTargetArray = $.isArray( value ),\n        isTargetObject = $.isPlainObject( value ),\n        viewsetObject = this.item.view/*,\n        safety = 100*/\n\n\n    if ( isTargetArray || isTargetObject ) {\n\n        if ( isTargetObject ) {\n            targetYear = value.year\n            targetMonth = value.month\n            targetDate = value.date\n        }\n        else {\n            targetYear = +value[0]\n            targetMonth = +value[1]\n            targetDate = +value[2]\n        }\n\n        // If we’re navigating months but the view is in a different\n        // month, navigate to the view’s year and month.\n        if ( options && options.nav && viewsetObject && viewsetObject.month !== targetMonth ) {\n            targetYear = viewsetObject.year\n            targetMonth = viewsetObject.month\n        }\n\n        // Figure out the expected target year and month.\n        targetDateObject = new Date( targetYear, targetMonth + ( options && options.nav ? options.nav : 0 ), 1 )\n        targetYear = targetDateObject.getFullYear()\n        targetMonth = targetDateObject.getMonth()\n\n        // If the month we’re going to doesn’t have enough days,\n        // keep decreasing the date until we reach the month’s last date.\n        while ( /*safety &&*/ new Date( targetYear, targetMonth, targetDate ).getMonth() !== targetMonth ) {\n            targetDate -= 1\n            /*safety -= 1\n            if ( !safety ) {\n                throw 'Fell into an infinite loop while navigating to ' + new Date( targetYear, targetMonth, targetDate ) + '.'\n            }*/\n        }\n\n        value = [ targetYear, targetMonth, targetDate ]\n    }\n\n    return value\n} //DatePicker.prototype.navigate\n\n\n/**\n * Normalize a date by setting the hours to midnight.\n */\nDatePicker.prototype.normalize = function( value/*, options*/ ) {\n    value.setHours( 0, 0, 0, 0 )\n    return value\n}\n\n\n/**\n * Measure the range of dates.\n */\nDatePicker.prototype.measure = function( type, value/*, options*/ ) {\n\n    var calendar = this\n\n    // If it’s anything false-y, remove the limits.\n    if ( !value ) {\n        value = type == 'min' ? -Infinity : Infinity\n    }\n\n    // If it’s a string, parse it.\n    else if ( typeof value == 'string' ) {\n        value = calendar.parse( type, value )\n    }\n\n    // If it's an integer, get a date relative to today.\n    else if ( _.isInteger( value ) ) {\n        value = calendar.now( type, value, { rel: value } )\n    }\n\n    return value\n} ///DatePicker.prototype.measure\n\n\n/**\n * Create a viewset object based on navigation.\n */\nDatePicker.prototype.viewset = function( type, dateObject/*, options*/ ) {\n    return this.create([ dateObject.year, dateObject.month, 1 ])\n}\n\n\n/**\n * Validate a date as enabled and shift if needed.\n */\nDatePicker.prototype.validate = function( type, dateObject, options ) {\n\n    var calendar = this,\n\n        // Keep a reference to the original date.\n        originalDateObject = dateObject,\n\n        // Make sure we have an interval.\n        interval = options && options.interval ? options.interval : 1,\n\n        // Check if the calendar enabled dates are inverted.\n        isFlippedBase = calendar.item.enable === -1,\n\n        // Check if we have any enabled dates after/before now.\n        hasEnabledBeforeTarget, hasEnabledAfterTarget,\n\n        // The min & max limits.\n        minLimitObject = calendar.item.min,\n        maxLimitObject = calendar.item.max,\n\n        // Check if we’ve reached the limit during shifting.\n        reachedMin, reachedMax,\n\n        // Check if the calendar is inverted and at least one weekday is enabled.\n        hasEnabledWeekdays = isFlippedBase && calendar.item.disable.filter( function( value ) {\n\n            // If there’s a date, check where it is relative to the target.\n            if ( $.isArray( value ) ) {\n                var dateTime = calendar.create( value ).pick\n                if ( dateTime < dateObject.pick ) hasEnabledBeforeTarget = true\n                else if ( dateTime > dateObject.pick ) hasEnabledAfterTarget = true\n            }\n\n            // Return only integers for enabled weekdays.\n            return _.isInteger( value )\n        }).length/*,\n\n        safety = 100*/\n\n\n\n    // Cases to validate for:\n    // [1] Not inverted and date disabled.\n    // [2] Inverted and some dates enabled.\n    // [3] Not inverted and out of range.\n    //\n    // Cases to **not** validate for:\n    // • Navigating months.\n    // • Not inverted and date enabled.\n    // • Inverted and all dates disabled.\n    // • ..and anything else.\n    if ( !options || (!options.nav && !options.defaultValue) ) if (\n        /* 1 */ ( !isFlippedBase && calendar.disabled( dateObject ) ) ||\n        /* 2 */ ( isFlippedBase && calendar.disabled( dateObject ) && ( hasEnabledWeekdays || hasEnabledBeforeTarget || hasEnabledAfterTarget ) ) ||\n        /* 3 */ ( !isFlippedBase && (dateObject.pick <= minLimitObject.pick || dateObject.pick >= maxLimitObject.pick) )\n    ) {\n\n\n        // When inverted, flip the direction if there aren’t any enabled weekdays\n        // and there are no enabled dates in the direction of the interval.\n        if ( isFlippedBase && !hasEnabledWeekdays && ( ( !hasEnabledAfterTarget && interval > 0 ) || ( !hasEnabledBeforeTarget && interval < 0 ) ) ) {\n            interval *= -1\n        }\n\n\n        // Keep looping until we reach an enabled date.\n        while ( /*safety &&*/ calendar.disabled( dateObject ) ) {\n\n            /*safety -= 1\n            if ( !safety ) {\n                throw 'Fell into an infinite loop while validating ' + dateObject.obj + '.'\n            }*/\n\n\n            // If we’ve looped into the next/prev month with a large interval, return to the original date and flatten the interval.\n            if ( Math.abs( interval ) > 1 && ( dateObject.month < originalDateObject.month || dateObject.month > originalDateObject.month ) ) {\n                dateObject = originalDateObject\n                interval = interval > 0 ? 1 : -1\n            }\n\n\n            // If we’ve reached the min/max limit, reverse the direction, flatten the interval and set it to the limit.\n            if ( dateObject.pick <= minLimitObject.pick ) {\n                reachedMin = true\n                interval = 1\n                dateObject = calendar.create([\n                    minLimitObject.year,\n                    minLimitObject.month,\n                    minLimitObject.date + (dateObject.pick === minLimitObject.pick ? 0 : -1)\n                ])\n            }\n            else if ( dateObject.pick >= maxLimitObject.pick ) {\n                reachedMax = true\n                interval = -1\n                dateObject = calendar.create([\n                    maxLimitObject.year,\n                    maxLimitObject.month,\n                    maxLimitObject.date + (dateObject.pick === maxLimitObject.pick ? 0 : 1)\n                ])\n            }\n\n\n            // If we’ve reached both limits, just break out of the loop.\n            if ( reachedMin && reachedMax ) {\n                break\n            }\n\n\n            // Finally, create the shifted date using the interval and keep looping.\n            dateObject = calendar.create([ dateObject.year, dateObject.month, dateObject.date + interval ])\n        }\n\n    } //endif\n\n\n    // Return the date object settled on.\n    return dateObject\n} //DatePicker.prototype.validate\n\n\n/**\n * Check if a date is disabled.\n */\nDatePicker.prototype.disabled = function( dateToVerify ) {\n\n    var\n        calendar = this,\n\n        // Filter through the disabled dates to check if this is one.\n        isDisabledMatch = calendar.item.disable.filter( function( dateToDisable ) {\n\n            // If the date is a number, match the weekday with 0index and `firstDay` check.\n            if ( _.isInteger( dateToDisable ) ) {\n                return dateToVerify.day === ( calendar.settings.firstDay ? dateToDisable : dateToDisable - 1 ) % 7\n            }\n\n            // If it’s an array or a native JS date, create and match the exact date.\n            if ( $.isArray( dateToDisable ) || _.isDate( dateToDisable ) ) {\n                return dateToVerify.pick === calendar.create( dateToDisable ).pick\n            }\n\n            // If it’s an object, match a date within the “from” and “to” range.\n            if ( $.isPlainObject( dateToDisable ) ) {\n                return calendar.withinRange( dateToDisable, dateToVerify )\n            }\n        })\n\n    // If this date matches a disabled date, confirm it’s not inverted.\n    isDisabledMatch = isDisabledMatch.length && !isDisabledMatch.filter(function( dateToDisable ) {\n        return $.isArray( dateToDisable ) && dateToDisable[3] == 'inverted' ||\n            $.isPlainObject( dateToDisable ) && dateToDisable.inverted\n    }).length\n\n    // Check the calendar “enabled” flag and respectively flip the\n    // disabled state. Then also check if it’s beyond the min/max limits.\n    return calendar.item.enable === -1 ? !isDisabledMatch : isDisabledMatch ||\n        dateToVerify.pick < calendar.item.min.pick ||\n        dateToVerify.pick > calendar.item.max.pick\n\n} //DatePicker.prototype.disabled\n\n\n/**\n * Parse a string into a usable type.\n */\nDatePicker.prototype.parse = function( type, value, options ) {\n\n    var calendar = this,\n        parsingObject = {}\n\n    // If it’s already parsed, we’re good.\n    if ( !value || typeof value != 'string' ) {\n        return value\n    }\n\n    // We need a `.format` to parse the value with.\n    if ( !( options && options.format ) ) {\n        options = options || {}\n        options.format = calendar.settings.format\n    }\n\n    // Convert the format into an array and then map through it.\n    calendar.formats.toArray( options.format ).map( function( label ) {\n\n        var\n            // Grab the formatting label.\n            formattingLabel = calendar.formats[ label ],\n\n            // The format length is from the formatting label function or the\n            // label length without the escaping exclamation (!) mark.\n            formatLength = formattingLabel ? _.trigger( formattingLabel, calendar, [ value, parsingObject ] ) : label.replace( /^!/, '' ).length\n\n        // If there's a format label, split the value up to the format length.\n        // Then add it to the parsing object with appropriate label.\n        if ( formattingLabel ) {\n            parsingObject[ label ] = value.substr( 0, formatLength )\n        }\n\n        // Update the value as the substring from format length to end.\n        value = value.substr( formatLength )\n    })\n\n    // Compensate for month 0index.\n    return [\n        parsingObject.yyyy || parsingObject.yy,\n        +( parsingObject.mm || parsingObject.m ) - 1,\n        parsingObject.dd || parsingObject.d\n    ]\n} //DatePicker.prototype.parse\n\n\n/**\n * Various formats to display the object in.\n */\nDatePicker.prototype.formats = (function() {\n\n    // Return the length of the first word in a collection.\n    function getWordLengthFromCollection( string, collection, dateObject ) {\n\n        // Grab the first word from the string.\n        // Regex pattern from http://stackoverflow.com/q/150033\n        var word = string.match( /[^\\x00-\\x7F]+|\\w+/ )[ 0 ]\n\n        // If there's no month index, add it to the date object\n        if ( !dateObject.mm && !dateObject.m ) {\n            dateObject.m = collection.indexOf( word ) + 1\n        }\n\n        // Return the length of the word.\n        return word.length\n    }\n\n    // Get the length of the first word in a string.\n    function getFirstWordLength( string ) {\n        return string.match( /\\w+/ )[ 0 ].length\n    }\n\n    return {\n\n        d: function( string, dateObject ) {\n\n            // If there's string, then get the digits length.\n            // Otherwise return the selected date.\n            return string ? _.digits( string ) : dateObject.date\n        },\n        dd: function( string, dateObject ) {\n\n            // If there's a string, then the length is always 2.\n            // Otherwise return the selected date with a leading zero.\n            return string ? 2 : _.lead( dateObject.date )\n        },\n        ddd: function( string, dateObject ) {\n\n            // If there's a string, then get the length of the first word.\n            // Otherwise return the short selected weekday.\n            return string ? getFirstWordLength( string ) : this.settings.weekdaysShort[ dateObject.day ]\n        },\n        dddd: function( string, dateObject ) {\n\n            // If there's a string, then get the length of the first word.\n            // Otherwise return the full selected weekday.\n            return string ? getFirstWordLength( string ) : this.settings.weekdaysFull[ dateObject.day ]\n        },\n        m: function( string, dateObject ) {\n\n            // If there's a string, then get the length of the digits\n            // Otherwise return the selected month with 0index compensation.\n            return string ? _.digits( string ) : dateObject.month + 1\n        },\n        mm: function( string, dateObject ) {\n\n            // If there's a string, then the length is always 2.\n            // Otherwise return the selected month with 0index and leading zero.\n            return string ? 2 : _.lead( dateObject.month + 1 )\n        },\n        mmm: function( string, dateObject ) {\n\n            var collection = this.settings.monthsShort\n\n            // If there's a string, get length of the relevant month from the short\n            // months collection. Otherwise return the selected month from that collection.\n            return string ? getWordLengthFromCollection( string, collection, dateObject ) : collection[ dateObject.month ]\n        },\n        mmmm: function( string, dateObject ) {\n\n            var collection = this.settings.monthsFull\n\n            // If there's a string, get length of the relevant month from the full\n            // months collection. Otherwise return the selected month from that collection.\n            return string ? getWordLengthFromCollection( string, collection, dateObject ) : collection[ dateObject.month ]\n        },\n        yy: function( string, dateObject ) {\n\n            // If there's a string, then the length is always 2.\n            // Otherwise return the selected year by slicing out the first 2 digits.\n            return string ? 2 : ( '' + dateObject.year ).slice( 2 )\n        },\n        yyyy: function( string, dateObject ) {\n\n            // If there's a string, then the length is always 4.\n            // Otherwise return the selected year.\n            return string ? 4 : dateObject.year\n        },\n\n        // Create an array by splitting the formatting string passed.\n        toArray: function( formatString ) { return formatString.split( /(d{1,4}|m{1,4}|y{4}|yy|!.)/g ) },\n\n        // Format an object into a string using the formatting options.\n        toString: function ( formatString, itemObject ) {\n            var calendar = this\n            return calendar.formats.toArray( formatString ).map( function( label ) {\n                return _.trigger( calendar.formats[ label ], calendar, [ 0, itemObject ] ) || label.replace( /^!/, '' )\n            }).join( '' )\n        }\n    }\n})() //DatePicker.prototype.formats\n\n\n\n\n/**\n * Check if two date units are the exact.\n */\nDatePicker.prototype.isDateExact = function( one, two ) {\n\n    var calendar = this\n\n    // When we’re working with weekdays, do a direct comparison.\n    if (\n        ( _.isInteger( one ) && _.isInteger( two ) ) ||\n        ( typeof one == 'boolean' && typeof two == 'boolean' )\n     ) {\n        return one === two\n    }\n\n    // When we’re working with date representations, compare the “pick” value.\n    if (\n        ( _.isDate( one ) || $.isArray( one ) ) &&\n        ( _.isDate( two ) || $.isArray( two ) )\n    ) {\n        return calendar.create( one ).pick === calendar.create( two ).pick\n    }\n\n    // When we’re working with range objects, compare the “from” and “to”.\n    if ( $.isPlainObject( one ) && $.isPlainObject( two ) ) {\n        return calendar.isDateExact( one.from, two.from ) && calendar.isDateExact( one.to, two.to )\n    }\n\n    return false\n}\n\n\n/**\n * Check if two date units overlap.\n */\nDatePicker.prototype.isDateOverlap = function( one, two ) {\n\n    var calendar = this,\n        firstDay = calendar.settings.firstDay ? 1 : 0\n\n    // When we’re working with a weekday index, compare the days.\n    if ( _.isInteger( one ) && ( _.isDate( two ) || $.isArray( two ) ) ) {\n        one = one % 7 + firstDay\n        return one === calendar.create( two ).day + 1\n    }\n    if ( _.isInteger( two ) && ( _.isDate( one ) || $.isArray( one ) ) ) {\n        two = two % 7 + firstDay\n        return two === calendar.create( one ).day + 1\n    }\n\n    // When we’re working with range objects, check if the ranges overlap.\n    if ( $.isPlainObject( one ) && $.isPlainObject( two ) ) {\n        return calendar.overlapRanges( one, two )\n    }\n\n    return false\n}\n\n\n/**\n * Flip the “enabled” state.\n */\nDatePicker.prototype.flipEnable = function(val) {\n    var itemObject = this.item\n    itemObject.enable = val || (itemObject.enable == -1 ? 1 : -1)\n}\n\n\n/**\n * Mark a collection of dates as “disabled”.\n */\nDatePicker.prototype.deactivate = function( type, datesToDisable ) {\n\n    var calendar = this,\n        disabledItems = calendar.item.disable.slice(0)\n\n\n    // If we’re flipping, that’s all we need to do.\n    if ( datesToDisable == 'flip' ) {\n        calendar.flipEnable()\n    }\n\n    else if ( datesToDisable === false ) {\n        calendar.flipEnable(1)\n        disabledItems = []\n    }\n\n    else if ( datesToDisable === true ) {\n        calendar.flipEnable(-1)\n        disabledItems = []\n    }\n\n    // Otherwise go through the dates to disable.\n    else {\n\n        datesToDisable.map(function( unitToDisable ) {\n\n            var matchFound\n\n            // When we have disabled items, check for matches.\n            // If something is matched, immediately break out.\n            for ( var index = 0; index < disabledItems.length; index += 1 ) {\n                if ( calendar.isDateExact( unitToDisable, disabledItems[index] ) ) {\n                    matchFound = true\n                    break\n                }\n            }\n\n            // If nothing was found, add the validated unit to the collection.\n            if ( !matchFound ) {\n                if (\n                    _.isInteger( unitToDisable ) ||\n                    _.isDate( unitToDisable ) ||\n                    $.isArray( unitToDisable ) ||\n                    ( $.isPlainObject( unitToDisable ) && unitToDisable.from && unitToDisable.to )\n                ) {\n                    disabledItems.push( unitToDisable )\n                }\n            }\n        })\n    }\n\n    // Return the updated collection.\n    return disabledItems\n} //DatePicker.prototype.deactivate\n\n\n/**\n * Mark a collection of dates as “enabled”.\n */\nDatePicker.prototype.activate = function( type, datesToEnable ) {\n\n    var calendar = this,\n        disabledItems = calendar.item.disable,\n        disabledItemsCount = disabledItems.length\n\n    // If we’re flipping, that’s all we need to do.\n    if ( datesToEnable == 'flip' ) {\n        calendar.flipEnable()\n    }\n\n    else if ( datesToEnable === true ) {\n        calendar.flipEnable(1)\n        disabledItems = []\n    }\n\n    else if ( datesToEnable === false ) {\n        calendar.flipEnable(-1)\n        disabledItems = []\n    }\n\n    // Otherwise go through the disabled dates.\n    else {\n\n        datesToEnable.map(function( unitToEnable ) {\n\n            var matchFound,\n                disabledUnit,\n                index,\n                isExactRange\n\n            // Go through the disabled items and try to find a match.\n            for ( index = 0; index < disabledItemsCount; index += 1 ) {\n\n                disabledUnit = disabledItems[index]\n\n                // When an exact match is found, remove it from the collection.\n                if ( calendar.isDateExact( disabledUnit, unitToEnable ) ) {\n                    matchFound = disabledItems[index] = null\n                    isExactRange = true\n                    break\n                }\n\n                // When an overlapped match is found, add the “inverted” state to it.\n                else if ( calendar.isDateOverlap( disabledUnit, unitToEnable ) ) {\n                    if ( $.isPlainObject( unitToEnable ) ) {\n                        unitToEnable.inverted = true\n                        matchFound = unitToEnable\n                    }\n                    else if ( $.isArray( unitToEnable ) ) {\n                        matchFound = unitToEnable\n                        if ( !matchFound[3] ) matchFound.push( 'inverted' )\n                    }\n                    else if ( _.isDate( unitToEnable ) ) {\n                        matchFound = [ unitToEnable.getFullYear(), unitToEnable.getMonth(), unitToEnable.getDate(), 'inverted' ]\n                    }\n                    break\n                }\n            }\n\n            // If a match was found, remove a previous duplicate entry.\n            if ( matchFound ) for ( index = 0; index < disabledItemsCount; index += 1 ) {\n                if ( calendar.isDateExact( disabledItems[index], unitToEnable ) ) {\n                    disabledItems[index] = null\n                    break\n                }\n            }\n\n            // In the event that we’re dealing with an exact range of dates,\n            // make sure there are no “inverted” dates because of it.\n            if ( isExactRange ) for ( index = 0; index < disabledItemsCount; index += 1 ) {\n                if ( calendar.isDateOverlap( disabledItems[index], unitToEnable ) ) {\n                    disabledItems[index] = null\n                    break\n                }\n            }\n\n            // If something is still matched, add it into the collection.\n            if ( matchFound ) {\n                disabledItems.push( matchFound )\n            }\n        })\n    }\n\n    // Return the updated collection.\n    return disabledItems.filter(function( val ) { return val != null })\n} //DatePicker.prototype.activate\n\n\n/**\n * Create a string for the nodes in the picker.\n */\nDatePicker.prototype.nodes = function( isOpen ) {\n\n    var\n        calendar = this,\n        settings = calendar.settings,\n        calendarItem = calendar.item,\n        nowObject = calendarItem.now,\n        selectedObject = calendarItem.select,\n        highlightedObject = calendarItem.highlight,\n        viewsetObject = calendarItem.view,\n        disabledCollection = calendarItem.disable,\n        minLimitObject = calendarItem.min,\n        maxLimitObject = calendarItem.max,\n\n\n        // Create the calendar table head using a copy of weekday labels collection.\n        // * We do a copy so we don't mutate the original array.\n        tableHead = (function( collection, fullCollection ) {\n\n            // If the first day should be Monday, move Sunday to the end.\n            if ( settings.firstDay ) {\n                collection.push( collection.shift() )\n                fullCollection.push( fullCollection.shift() )\n            }\n\n            // Create and return the table head group.\n            return _.node(\n                'thead',\n                _.node(\n                    'tr',\n                    _.group({\n                        min: 0,\n                        max: DAYS_IN_WEEK - 1,\n                        i: 1,\n                        node: 'th',\n                        item: function( counter ) {\n                            return [\n                                collection[ counter ],\n                                settings.klass.weekdays,\n                                'scope=col title=\"' + fullCollection[ counter ] + '\"'\n                            ]\n                        }\n                    })\n                )\n            ) //endreturn\n        })( ( settings.showWeekdaysFull ? settings.weekdaysFull : settings.weekdaysShort ).slice( 0 ), settings.weekdaysFull.slice( 0 ) ), //tableHead\n\n\n        // Create the nav for next/prev month.\n        createMonthNav = function( next ) {\n\n            // Otherwise, return the created month tag.\n            return _.node(\n                'div',\n                ' ',\n                settings.klass[ 'nav' + ( next ? 'Next' : 'Prev' ) ] + (\n\n                    // If the focused month is outside the range, disabled the button.\n                    ( next && viewsetObject.year >= maxLimitObject.year && viewsetObject.month >= maxLimitObject.month ) ||\n                    ( !next && viewsetObject.year <= minLimitObject.year && viewsetObject.month <= minLimitObject.month ) ?\n                    ' ' + settings.klass.navDisabled : ''\n                ),\n                'data-nav=' + ( next || -1 ) + ' ' +\n                _.ariaAttr({\n                    role: 'button',\n                    controls: calendar.$node[0].id + '_table'\n                }) + ' ' +\n                'title=\"' + (next ? settings.labelMonthNext : settings.labelMonthPrev ) + '\"'\n            ) //endreturn\n        }, //createMonthNav\n\n\n        // Create the month label.\n        createMonthLabel = function() {\n\n            var monthsCollection = settings.showMonthsShort ? settings.monthsShort : settings.monthsFull\n\n            // If there are months to select, add a dropdown menu.\n            if ( settings.selectMonths ) {\n\n                return _.node( 'select',\n                    _.group({\n                        min: 0,\n                        max: 11,\n                        i: 1,\n                        node: 'option',\n                        item: function( loopedMonth ) {\n\n                            return [\n\n                                // The looped month and no classes.\n                                monthsCollection[ loopedMonth ], 0,\n\n                                // Set the value and selected index.\n                                'value=' + loopedMonth +\n                                ( viewsetObject.month == loopedMonth ? ' selected' : '' ) +\n                                (\n                                    (\n                                        ( viewsetObject.year == minLimitObject.year && loopedMonth < minLimitObject.month ) ||\n                                        ( viewsetObject.year == maxLimitObject.year && loopedMonth > maxLimitObject.month )\n                                    ) ?\n                                    ' disabled' : ''\n                                )\n                            ]\n                        }\n                    }),\n                    settings.klass.selectMonth,\n                    ( isOpen ? '' : 'disabled' ) + ' ' +\n                    _.ariaAttr({ controls: calendar.$node[0].id + '_table' }) + ' ' +\n                    'title=\"' + settings.labelMonthSelect + '\"'\n                )\n            }\n\n            // If there's a need for a month selector\n            return _.node( 'div', monthsCollection[ viewsetObject.month ], settings.klass.month )\n        }, //createMonthLabel\n\n\n        // Create the year label.\n        createYearLabel = function() {\n\n            var focusedYear = viewsetObject.year,\n\n            // If years selector is set to a literal \"true\", set it to 5. Otherwise\n            // divide in half to get half before and half after focused year.\n            numberYears = settings.selectYears === true ? 5 : ~~( settings.selectYears / 2 )\n\n            // If there are years to select, add a dropdown menu.\n            if ( numberYears ) {\n\n                var\n                    minYear = minLimitObject.year,\n                    maxYear = maxLimitObject.year,\n                    lowestYear = focusedYear - numberYears,\n                    highestYear = focusedYear + numberYears\n\n                // If the min year is greater than the lowest year, increase the highest year\n                // by the difference and set the lowest year to the min year.\n                if ( minYear > lowestYear ) {\n                    highestYear += minYear - lowestYear\n                    lowestYear = minYear\n                }\n\n                // If the max year is less than the highest year, decrease the lowest year\n                // by the lower of the two: available and needed years. Then set the\n                // highest year to the max year.\n                if ( maxYear < highestYear ) {\n\n                    var availableYears = lowestYear - minYear,\n                        neededYears = highestYear - maxYear\n\n                    lowestYear -= availableYears > neededYears ? neededYears : availableYears\n                    highestYear = maxYear\n                }\n\n                return _.node( 'select',\n                    _.group({\n                        min: lowestYear,\n                        max: highestYear,\n                        i: 1,\n                        node: 'option',\n                        item: function( loopedYear ) {\n                            return [\n\n                                // The looped year and no classes.\n                                loopedYear, 0,\n\n                                // Set the value and selected index.\n                                'value=' + loopedYear + ( focusedYear == loopedYear ? ' selected' : '' )\n                            ]\n                        }\n                    }),\n                    settings.klass.selectYear,\n                    ( isOpen ? '' : 'disabled' ) + ' ' + _.ariaAttr({ controls: calendar.$node[0].id + '_table' }) + ' ' +\n                    'title=\"' + settings.labelYearSelect + '\"'\n                )\n            }\n\n            // Otherwise just return the year focused\n            return _.node( 'div', focusedYear, settings.klass.year )\n        } //createYearLabel\n\n\n    // Create and return the entire calendar.\n    return _.node(\n        'div',\n        ( settings.selectYears ? createYearLabel() + createMonthLabel() : createMonthLabel() + createYearLabel() ) +\n        createMonthNav() + createMonthNav( 1 ),\n        settings.klass.header\n    ) + _.node(\n        'table',\n        tableHead +\n        _.node(\n            'tbody',\n            _.group({\n                min: 0,\n                max: WEEKS_IN_CALENDAR - 1,\n                i: 1,\n                node: 'tr',\n                item: function( rowCounter ) {\n\n                    // If Monday is the first day and the month starts on Sunday, shift the date back a week.\n                    var shiftDateBy = settings.firstDay && calendar.create([ viewsetObject.year, viewsetObject.month, 1 ]).day === 0 ? -7 : 0\n\n                    return [\n                        _.group({\n                            min: DAYS_IN_WEEK * rowCounter - viewsetObject.day + shiftDateBy + 1, // Add 1 for weekday 0index\n                            max: function() {\n                                return this.min + DAYS_IN_WEEK - 1\n                            },\n                            i: 1,\n                            node: 'td',\n                            item: function( targetDate ) {\n\n                                // Convert the time date from a relative date to a target date.\n                                targetDate = calendar.create([ viewsetObject.year, viewsetObject.month, targetDate + ( settings.firstDay ? 1 : 0 ) ])\n\n                                var isSelected = selectedObject && selectedObject.pick == targetDate.pick,\n                                    isHighlighted = highlightedObject && highlightedObject.pick == targetDate.pick,\n                                    isDisabled = disabledCollection && calendar.disabled( targetDate ) || targetDate.pick < minLimitObject.pick || targetDate.pick > maxLimitObject.pick,\n                                    formattedDate = _.trigger( calendar.formats.toString, calendar, [ settings.format, targetDate ] )\n\n                                return [\n                                    _.node(\n                                        'div',\n                                        targetDate.date,\n                                        (function( klasses ) {\n\n                                            // Add the `infocus` or `outfocus` classes based on month in view.\n                                            klasses.push( viewsetObject.month == targetDate.month ? settings.klass.infocus : settings.klass.outfocus )\n\n                                            // Add the `today` class if needed.\n                                            if ( nowObject.pick == targetDate.pick ) {\n                                                klasses.push( settings.klass.now )\n                                            }\n\n                                            // Add the `selected` class if something's selected and the time matches.\n                                            if ( isSelected ) {\n                                                klasses.push( settings.klass.selected )\n                                            }\n\n                                            // Add the `highlighted` class if something's highlighted and the time matches.\n                                            if ( isHighlighted ) {\n                                                klasses.push( settings.klass.highlighted )\n                                            }\n\n                                            // Add the `disabled` class if something's disabled and the object matches.\n                                            if ( isDisabled ) {\n                                                klasses.push( settings.klass.disabled )\n                                            }\n\n                                            return klasses.join( ' ' )\n                                        })([ settings.klass.day ]),\n                                        'data-pick=' + targetDate.pick + ' ' + _.ariaAttr({\n                                            role: 'gridcell',\n                                            label: formattedDate,\n                                            selected: isSelected && calendar.$node.val() === formattedDate ? true : null,\n                                            activedescendant: isHighlighted ? true : null,\n                                            disabled: isDisabled ? true : null\n                                        })\n                                    ),\n                                    '',\n                                    _.ariaAttr({ role: 'presentation' })\n                                ] //endreturn\n                            }\n                        })\n                    ] //endreturn\n                }\n            })\n        ),\n        settings.klass.table,\n        'id=\"' + calendar.$node[0].id + '_table' + '\" ' + _.ariaAttr({\n            role: 'grid',\n            controls: calendar.$node[0].id,\n            readonly: true\n        })\n    ) +\n\n    // * For Firefox forms to submit, make sure to set the buttons’ `type` attributes as “button”.\n    _.node(\n        'div',\n        _.node( 'button', settings.today, settings.klass.buttonToday,\n            'type=button data-pick=' + nowObject.pick +\n            ( isOpen && !calendar.disabled(nowObject) ? '' : ' disabled' ) + ' ' +\n            _.ariaAttr({ controls: calendar.$node[0].id }) ) +\n        _.node( 'button', settings.clear, settings.klass.buttonClear,\n            'type=button data-clear=1' +\n            ( isOpen ? '' : ' disabled' ) + ' ' +\n            _.ariaAttr({ controls: calendar.$node[0].id }) ) +\n        _.node('button', settings.close, settings.klass.buttonClose,\n            'type=button data-close=true ' +\n            ( isOpen ? '' : ' disabled' ) + ' ' +\n            _.ariaAttr({ controls: calendar.$node[0].id }) ),\n        settings.klass.footer\n    ) //endreturn\n} //DatePicker.prototype.nodes\n\n\n\n\n/**\n * The date picker defaults.\n */\nDatePicker.defaults = (function( prefix ) {\n\n    return {\n\n        // The title label to use for the month nav buttons\n        labelMonthNext: 'Next month',\n        labelMonthPrev: 'Previous month',\n\n        // The title label to use for the dropdown selectors\n        labelMonthSelect: 'Select a month',\n        labelYearSelect: 'Select a year',\n\n        // Months and weekdays\n        monthsFull: [ 'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December' ],\n        monthsShort: [ 'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec' ],\n        weekdaysFull: [ 'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday' ],\n        weekdaysShort: [ 'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat' ],\n\n        // Today and clear\n        today: 'Today',\n        clear: 'Clear',\n        close: 'Close',\n\n        // Picker close behavior\n        closeOnSelect: true,\n        closeOnClear: true,\n\n        // The format to show on the `input` element\n        format: 'd mmmm, yyyy',\n\n        // Classes\n        klass: {\n\n            table: prefix + 'table',\n\n            header: prefix + 'header',\n\n            navPrev: prefix + 'nav--prev',\n            navNext: prefix + 'nav--next',\n            navDisabled: prefix + 'nav--disabled',\n\n            month: prefix + 'month',\n            year: prefix + 'year',\n\n            selectMonth: prefix + 'select--month',\n            selectYear: prefix + 'select--year',\n\n            weekdays: prefix + 'weekday',\n\n            day: prefix + 'day',\n            disabled: prefix + 'day--disabled',\n            selected: prefix + 'day--selected',\n            highlighted: prefix + 'day--highlighted',\n            now: prefix + 'day--today',\n            infocus: prefix + 'day--infocus',\n            outfocus: prefix + 'day--outfocus',\n\n            footer: prefix + 'footer',\n\n            buttonClear: prefix + 'button--clear',\n            buttonToday: prefix + 'button--today',\n            buttonClose: prefix + 'button--close'\n        }\n    }\n})( Picker.klasses().picker + '__' )\n\n\n\n\n\n/**\n * Extend the picker to add the date picker.\n */\nPicker.extend( 'pickadate', DatePicker )\n\n\n}));\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/pickadate-webpack/lib/picker.date.js?");

/***/ }),

/***/ "./node_modules/pickadate-webpack/lib/picker.js":
/*!******************************************************!*\
  !*** ./node_modules/pickadate-webpack/lib/picker.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * pickadate.js v3.5.6, 2015/04/20\n * By Amsul, http://amsul.ca\n * Hosted on http://amsul.github.io/pickadate.js\n * Licensed under MIT\n */\n\n(function ( factory ) {\n\n    // Node.js/browserify.\n    if ( true )\n        module.exports = factory( __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\") )\n\n    // Browser globals.\n    else {}\n\n}(function( $ ) {\n\nvar $window = $( window )\nvar $document = $( document )\nvar $html = $( document.documentElement )\nvar supportsTransitions = document.documentElement.style.transition != null\n\n\n/**\n * The picker constructor that creates a blank picker.\n */\nfunction PickerConstructor( ELEMENT, NAME, COMPONENT, OPTIONS ) {\n\n    // If there’s no element, return the picker constructor.\n    if ( !ELEMENT ) return PickerConstructor\n\n\n    var\n        IS_DEFAULT_THEME = false,\n\n\n        // The state of the picker.\n        STATE = {\n            id: ELEMENT.id || 'P' + Math.abs( ~~(Math.random() * new Date()) )\n        },\n\n\n        // Merge the defaults and options passed.\n        SETTINGS = COMPONENT ? $.extend( true, {}, COMPONENT.defaults, OPTIONS ) : OPTIONS || {},\n\n\n        // Merge the default classes with the settings classes.\n        CLASSES = $.extend( {}, PickerConstructor.klasses(), SETTINGS.klass ),\n\n\n        // The element node wrapper into a jQuery object.\n        $ELEMENT = $( ELEMENT ),\n\n\n        // Pseudo picker constructor.\n        PickerInstance = function() {\n            return this.start()\n        },\n\n\n        // The picker prototype.\n        P = PickerInstance.prototype = {\n\n            constructor: PickerInstance,\n\n            $node: $ELEMENT,\n\n\n            /**\n             * Initialize everything\n             */\n            start: function() {\n\n                // If it’s already started, do nothing.\n                if ( STATE && STATE.start ) return P\n\n\n                // Update the picker states.\n                STATE.methods = {}\n                STATE.start = true\n                STATE.open = false\n                STATE.type = ELEMENT.type\n\n\n                // Confirm focus state, convert into text input to remove UA stylings,\n                // and set as readonly to prevent keyboard popup.\n                ELEMENT.autofocus = ELEMENT == getActiveElement()\n                ELEMENT.readOnly = !SETTINGS.editable\n                ELEMENT.id = ELEMENT.id || STATE.id\n                if ( ELEMENT.type != 'text' ) {\n                    ELEMENT.type = 'text'\n                }\n\n\n                // Create a new picker component with the settings.\n                P.component = new COMPONENT(P, SETTINGS)\n\n\n                // Create the picker root and then prepare it.\n                P.$root = $( '<div class=\"' + CLASSES.picker + '\" id=\"' + ELEMENT.id + '_root\" />' )\n                prepareElementRoot()\n\n\n                // Create the picker holder and then prepare it.\n                P.$holder = $( createWrappedComponent() ).appendTo( P.$root )\n                prepareElementHolder()\n\n\n                // If there’s a format for the hidden input element, create the element.\n                if ( SETTINGS.formatSubmit ) {\n                    prepareElementHidden()\n                }\n\n\n                // Prepare the input element.\n                prepareElement()\n\n\n                // Insert the hidden input as specified in the settings.\n                if ( SETTINGS.containerHidden ) $( SETTINGS.containerHidden ).append( P._hidden )\n                else $ELEMENT.after( P._hidden )\n\n\n                // Insert the root as specified in the settings.\n                if ( SETTINGS.container ) $( SETTINGS.container ).append( P.$root )\n                else $ELEMENT.after( P.$root )\n\n\n                // Bind the default component and settings events.\n                P.on({\n                    start: P.component.onStart,\n                    render: P.component.onRender,\n                    stop: P.component.onStop,\n                    open: P.component.onOpen,\n                    close: P.component.onClose,\n                    set: P.component.onSet\n                }).on({\n                    start: SETTINGS.onStart,\n                    render: SETTINGS.onRender,\n                    stop: SETTINGS.onStop,\n                    open: SETTINGS.onOpen,\n                    close: SETTINGS.onClose,\n                    set: SETTINGS.onSet\n                })\n\n\n                // Once we’re all set, check the theme in use.\n                IS_DEFAULT_THEME = isUsingDefaultTheme( P.$holder[0] )\n\n\n                // If the element has autofocus, open the picker.\n                if ( ELEMENT.autofocus ) {\n                    P.open()\n                }\n\n\n                // Trigger queued the “start” and “render” events.\n                return P.trigger( 'start' ).trigger( 'render' )\n            }, //start\n\n\n            /**\n             * Render a new picker\n             */\n            render: function( entireComponent ) {\n\n                // Insert a new component holder in the root or box.\n                if ( entireComponent ) {\n                    P.$holder = $( createWrappedComponent() )\n                    prepareElementHolder()\n                    P.$root.html( P.$holder )\n                }\n                else P.$root.find( '.' + CLASSES.box ).html( P.component.nodes( STATE.open ) )\n\n                // Trigger the queued “render” events.\n                return P.trigger( 'render' )\n            }, //render\n\n\n            /**\n             * Destroy everything\n             */\n            stop: function() {\n\n                // If it’s already stopped, do nothing.\n                if ( !STATE.start ) return P\n\n                // Then close the picker.\n                P.close()\n\n                // Remove the hidden field.\n                if ( P._hidden ) {\n                    P._hidden.parentNode.removeChild( P._hidden )\n                }\n\n                // Remove the root.\n                P.$root.remove()\n\n                // Remove the input class, remove the stored data, and unbind\n                // the events (after a tick for IE - see `P.close`).\n                $ELEMENT.removeClass( CLASSES.input ).removeData( NAME )\n                setTimeout( function() {\n                    $ELEMENT.off( '.' + STATE.id )\n                }, 0)\n\n                // Restore the element state\n                ELEMENT.type = STATE.type\n                ELEMENT.readOnly = false\n\n                // Trigger the queued “stop” events.\n                P.trigger( 'stop' )\n\n                // Reset the picker states.\n                STATE.methods = {}\n                STATE.start = false\n\n                return P\n            }, //stop\n\n\n            /**\n             * Open up the picker\n             */\n            open: function( dontGiveFocus ) {\n\n                // If it’s already open, do nothing.\n                if ( STATE.open ) return P\n\n                // Add the “active” class.\n                $ELEMENT.addClass( CLASSES.active )\n                aria( ELEMENT, 'expanded', true )\n\n                // * A Firefox bug, when `html` has `overflow:hidden`, results in\n                //   killing transitions :(. So add the “opened” state on the next tick.\n                //   Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=625289\n                setTimeout( function() {\n\n                    // Add the “opened” class to the picker root.\n                    P.$root.addClass( CLASSES.opened )\n                    aria( P.$root[0], 'hidden', false )\n\n                }, 0 )\n\n                // If we have to give focus, bind the element and doc events.\n                if ( dontGiveFocus !== false ) {\n\n                    // Set it as open.\n                    STATE.open = true\n\n                    // Prevent the page from scrolling.\n                    if ( IS_DEFAULT_THEME ) {\n                        $html.\n                            css( 'overflow', 'hidden' ).\n                            css( 'padding-right', '+=' + getScrollbarWidth() )\n                    }\n\n                    // Pass focus to the root element’s jQuery object.\n                    focusPickerOnceOpened()\n\n                    // Bind the document events.\n                    $document.on( 'click.' + STATE.id + ' focusin.' + STATE.id, function( event ) {\n\n                        var target = event.target\n\n                        // If the target of the event is not the element, close the picker picker.\n                        // * Don’t worry about clicks or focusins on the root because those don’t bubble up.\n                        //   Also, for Firefox, a click on an `option` element bubbles up directly\n                        //   to the doc. So make sure the target wasn't the doc.\n                        // * In Firefox stopPropagation() doesn’t prevent right-click events from bubbling,\n                        //   which causes the picker to unexpectedly close when right-clicking it. So make\n                        //   sure the event wasn’t a right-click.\n                        if ( target != ELEMENT && target != document && event.which != 3 ) {\n\n                            // If the target was the holder that covers the screen,\n                            // keep the element focused to maintain tabindex.\n                            P.close( target === P.$holder[0] )\n                        }\n\n                    }).on( 'keydown.' + STATE.id, function( event ) {\n\n                        var\n                            // Get the keycode.\n                            keycode = event.keyCode,\n\n                            // Translate that to a selection change.\n                            keycodeToMove = P.component.key[ keycode ],\n\n                            // Grab the target.\n                            target = event.target\n\n\n                        // On escape, close the picker and give focus.\n                        if ( keycode == 27 ) {\n                            P.close( true )\n                        }\n\n\n                        // Check if there is a key movement or “enter” keypress on the element.\n                        else if ( target == P.$holder[0] && ( keycodeToMove || keycode == 13 ) ) {\n\n                            // Prevent the default action to stop page movement.\n                            event.preventDefault()\n\n                            // Trigger the key movement action.\n                            if ( keycodeToMove ) {\n                                PickerConstructor._.trigger( P.component.key.go, P, [ PickerConstructor._.trigger( keycodeToMove ) ] )\n                            }\n\n                            // On “enter”, if the highlighted item isn’t disabled, set the value and close.\n                            else if ( !P.$root.find( '.' + CLASSES.highlighted ).hasClass( CLASSES.disabled ) ) {\n                                P.set( 'select', P.component.item.highlight )\n                                if ( SETTINGS.closeOnSelect ) {\n                                    P.close( true )\n                                }\n                            }\n                        }\n\n\n                        // If the target is within the root and “enter” is pressed,\n                        // prevent the default action and trigger a click on the target instead.\n                        else if ( $.contains( P.$root[0], target ) && keycode == 13 ) {\n                            event.preventDefault()\n                            target.click()\n                        }\n                    })\n                }\n\n                // Trigger the queued “open” events.\n                return P.trigger( 'open' )\n            }, //open\n\n\n            /**\n             * Close the picker\n             */\n            close: function( giveFocus ) {\n\n                // If we need to give focus, do it before changing states.\n                if ( giveFocus ) {\n                    if ( SETTINGS.editable ) {\n                        ELEMENT.focus()\n                    }\n                    else {\n                        // ....ah yes! It would’ve been incomplete without a crazy workaround for IE :|\n                        // The focus is triggered *after* the close has completed - causing it\n                        // to open again. So unbind and rebind the event at the next tick.\n                        P.$holder.off( 'focus.toOpen' ).focus()\n                        setTimeout( function() {\n                            P.$holder.on( 'focus.toOpen', handleFocusToOpenEvent )\n                        }, 0 )\n                    }\n                }\n\n                // Remove the “active” class.\n                $ELEMENT.removeClass( CLASSES.active )\n                aria( ELEMENT, 'expanded', false )\n\n                // * A Firefox bug, when `html` has `overflow:hidden`, results in\n                //   killing transitions :(. So remove the “opened” state on the next tick.\n                //   Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=625289\n                setTimeout( function() {\n\n                    // Remove the “opened” and “focused” class from the picker root.\n                    P.$root.removeClass( CLASSES.opened + ' ' + CLASSES.focused )\n                    aria( P.$root[0], 'hidden', true )\n\n                }, 0 )\n\n                // If it’s already closed, do nothing more.\n                if ( !STATE.open ) return P\n\n                // Set it as closed.\n                STATE.open = false\n\n                // Allow the page to scroll.\n                if ( IS_DEFAULT_THEME ) {\n                    $html.\n                        css( 'overflow', '' ).\n                        css( 'padding-right', '-=' + getScrollbarWidth() )\n                }\n\n                // Unbind the document events.\n                $document.off( '.' + STATE.id )\n\n                // Trigger the queued “close” events.\n                return P.trigger( 'close' )\n            }, //close\n\n\n            /**\n             * Clear the values\n             */\n            clear: function( options ) {\n                return P.set( 'clear', null, options )\n            }, //clear\n\n\n            /**\n             * Set something\n             */\n            set: function( thing, value, options ) {\n\n                var thingItem, thingValue,\n                    thingIsObject = $.isPlainObject( thing ),\n                    thingObject = thingIsObject ? thing : {}\n\n                // Make sure we have usable options.\n                options = thingIsObject && $.isPlainObject( value ) ? value : options || {}\n\n                if ( thing ) {\n\n                    // If the thing isn’t an object, make it one.\n                    if ( !thingIsObject ) {\n                        thingObject[ thing ] = value\n                    }\n\n                    // Go through the things of items to set.\n                    for ( thingItem in thingObject ) {\n\n                        // Grab the value of the thing.\n                        thingValue = thingObject[ thingItem ]\n\n                        // First, if the item exists and there’s a value, set it.\n                        if ( thingItem in P.component.item ) {\n                            if ( thingValue === undefined ) thingValue = null\n                            P.component.set( thingItem, thingValue, options )\n                        }\n\n                        // Then, check to update the element value and broadcast a change.\n                        if ( thingItem == 'select' || thingItem == 'clear' ) {\n                            $ELEMENT.\n                                val( thingItem == 'clear' ? '' : P.get( thingItem, SETTINGS.format ) ).\n                                trigger( 'change' )\n                        }\n                    }\n\n                    // Render a new picker.\n                    P.render()\n                }\n\n                // When the method isn’t muted, trigger queued “set” events and pass the `thingObject`.\n                return options.muted ? P : P.trigger( 'set', thingObject )\n            }, //set\n\n\n            /**\n             * Get something\n             */\n            get: function( thing, format ) {\n\n                // Make sure there’s something to get.\n                thing = thing || 'value'\n\n                // If a picker state exists, return that.\n                if ( STATE[ thing ] != null ) {\n                    return STATE[ thing ]\n                }\n\n                // Return the submission value, if that.\n                if ( thing == 'valueSubmit' ) {\n                    if ( P._hidden ) {\n                        return P._hidden.value\n                    }\n                    thing = 'value'\n                }\n\n                // Return the value, if that.\n                if ( thing == 'value' ) {\n                    return ELEMENT.value\n                }\n\n                // Check if a component item exists, return that.\n                if ( thing in P.component.item ) {\n                    if ( typeof format == 'string' ) {\n                        var thingValue = P.component.get( thing )\n                        return thingValue ?\n                            PickerConstructor._.trigger(\n                                P.component.formats.toString,\n                                P.component,\n                                [ format, thingValue ]\n                            ) : ''\n                    }\n                    return P.component.get( thing )\n                }\n            }, //get\n\n\n\n            /**\n             * Bind events on the things.\n             */\n            on: function( thing, method, internal ) {\n\n                var thingName, thingMethod,\n                    thingIsObject = $.isPlainObject( thing ),\n                    thingObject = thingIsObject ? thing : {}\n\n                if ( thing ) {\n\n                    // If the thing isn’t an object, make it one.\n                    if ( !thingIsObject ) {\n                        thingObject[ thing ] = method\n                    }\n\n                    // Go through the things to bind to.\n                    for ( thingName in thingObject ) {\n\n                        // Grab the method of the thing.\n                        thingMethod = thingObject[ thingName ]\n\n                        // If it was an internal binding, prefix it.\n                        if ( internal ) {\n                            thingName = '_' + thingName\n                        }\n\n                        // Make sure the thing methods collection exists.\n                        STATE.methods[ thingName ] = STATE.methods[ thingName ] || []\n\n                        // Add the method to the relative method collection.\n                        STATE.methods[ thingName ].push( thingMethod )\n                    }\n                }\n\n                return P\n            }, //on\n\n\n\n            /**\n             * Unbind events on the things.\n             */\n            off: function() {\n                var i, thingName,\n                    names = arguments;\n                for ( i = 0, namesCount = names.length; i < namesCount; i += 1 ) {\n                    thingName = names[i]\n                    if ( thingName in STATE.methods ) {\n                        delete STATE.methods[thingName]\n                    }\n                }\n                return P\n            },\n\n\n            /**\n             * Fire off method events.\n             */\n            trigger: function( name, data ) {\n                var _trigger = function( name ) {\n                    var methodList = STATE.methods[ name ]\n                    if ( methodList ) {\n                        methodList.map( function( method ) {\n                            PickerConstructor._.trigger( method, P, [ data ] )\n                        })\n                    }\n                }\n                _trigger( '_' + name )\n                _trigger( name )\n                return P\n            } //trigger\n        } //PickerInstance.prototype\n\n\n    /**\n     * Wrap the picker holder components together.\n     */\n    function createWrappedComponent() {\n\n        // Create a picker wrapper holder\n        return PickerConstructor._.node( 'div',\n\n            // Create a picker wrapper node\n            PickerConstructor._.node( 'div',\n\n                // Create a picker frame\n                PickerConstructor._.node( 'div',\n\n                    // Create a picker box node\n                    PickerConstructor._.node( 'div',\n\n                        // Create the components nodes.\n                        P.component.nodes( STATE.open ),\n\n                        // The picker box class\n                        CLASSES.box\n                    ),\n\n                    // Picker wrap class\n                    CLASSES.wrap\n                ),\n\n                // Picker frame class\n                CLASSES.frame\n            ),\n\n            // Picker holder class\n            CLASSES.holder,\n\n            'tabindex=\"-1\"'\n        ) //endreturn\n    } //createWrappedComponent\n\n\n\n    /**\n     * Prepare the input element with all bindings.\n     */\n    function prepareElement() {\n\n        $ELEMENT.\n\n            // Store the picker data by component name.\n            data(NAME, P).\n\n            // Add the “input” class name.\n            addClass(CLASSES.input).\n\n            // If there’s a `data-value`, update the value of the element.\n            val( $ELEMENT.data('value') ?\n                P.get('select', SETTINGS.format) :\n                ELEMENT.value\n            )\n\n\n        // Only bind keydown events if the element isn’t editable.\n        if ( !SETTINGS.editable ) {\n\n            $ELEMENT.\n\n                // On focus/click, open the picker.\n                on( 'focus.' + STATE.id + ' click.' + STATE.id, function(event) {\n                    event.preventDefault()\n                    P.open()\n                }).\n\n                // Handle keyboard event based on the picker being opened or not.\n                on( 'keydown.' + STATE.id, handleKeydownEvent )\n        }\n\n\n        // Update the aria attributes.\n        aria(ELEMENT, {\n            haspopup: true,\n            expanded: false,\n            readonly: false,\n            owns: ELEMENT.id + '_root'\n        })\n    }\n\n\n    /**\n     * Prepare the root picker element with all bindings.\n     */\n    function prepareElementRoot() {\n        aria( P.$root[0], 'hidden', true )\n    }\n\n\n     /**\n      * Prepare the holder picker element with all bindings.\n      */\n    function prepareElementHolder() {\n\n        P.$holder.\n\n            on({\n\n                // For iOS8.\n                keydown: handleKeydownEvent,\n\n                'focus.toOpen': handleFocusToOpenEvent,\n\n                blur: function() {\n                    // Remove the “target” class.\n                    $ELEMENT.removeClass( CLASSES.target )\n                },\n\n                // When something within the holder is focused, stop from bubbling\n                // to the doc and remove the “focused” state from the root.\n                focusin: function( event ) {\n                    P.$root.removeClass( CLASSES.focused )\n                    event.stopPropagation()\n                },\n\n                // When something within the holder is clicked, stop it\n                // from bubbling to the doc.\n                'mousedown click': function( event ) {\n\n                    var target = event.target\n\n                    // Make sure the target isn’t the root holder so it can bubble up.\n                    if ( target != P.$holder[0] ) {\n\n                        event.stopPropagation()\n\n                        // * For mousedown events, cancel the default action in order to\n                        //   prevent cases where focus is shifted onto external elements\n                        //   when using things like jQuery mobile or MagnificPopup (ref: #249 & #120).\n                        //   Also, for Firefox, don’t prevent action on the `option` element.\n                        if ( event.type == 'mousedown' && !$( target ).is( 'input, select, textarea, button, option' )) {\n\n                            event.preventDefault()\n\n                            // Re-focus onto the holder so that users can click away\n                            // from elements focused within the picker.\n                            P.$holder[0].focus()\n                        }\n                    }\n                }\n\n            }).\n\n            // If there’s a click on an actionable element, carry out the actions.\n            on( 'click', '[data-pick], [data-nav], [data-clear], [data-close]', function() {\n\n                var $target = $( this ),\n                    targetData = $target.data(),\n                    targetDisabled = $target.hasClass( CLASSES.navDisabled ) || $target.hasClass( CLASSES.disabled ),\n\n                    // * For IE, non-focusable elements can be active elements as well\n                    //   (http://stackoverflow.com/a/2684561).\n                    activeElement = getActiveElement()\n                    activeElement = activeElement && ( activeElement.type || activeElement.href )\n\n                // If it’s disabled or nothing inside is actively focused, re-focus the element.\n                if ( targetDisabled || activeElement && !$.contains( P.$root[0], activeElement ) ) {\n                    P.$holder[0].focus()\n                }\n\n                // If something is superficially changed, update the `highlight` based on the `nav`.\n                if ( !targetDisabled && targetData.nav ) {\n                    P.set( 'highlight', P.component.item.highlight, { nav: targetData.nav } )\n                }\n\n                // If something is picked, set `select` then close with focus.\n                else if ( !targetDisabled && 'pick' in targetData ) {\n                    P.set( 'select', targetData.pick )\n                    if ( SETTINGS.closeOnSelect ) {\n                        P.close( true )\n                    }\n                }\n\n                // If a “clear” button is pressed, empty the values and close with focus.\n                else if ( targetData.clear ) {\n                    P.clear()\n                    if ( SETTINGS.closeOnClear ) {\n                        P.close( true )\n                    }\n                }\n\n                else if ( targetData.close ) {\n                    P.close( true )\n                }\n\n            }) //P.$holder\n\n    }\n\n\n     /**\n      * Prepare the hidden input element along with all bindings.\n      */\n    function prepareElementHidden() {\n\n        var name\n\n        if ( SETTINGS.hiddenName === true ) {\n            name = ELEMENT.name\n            ELEMENT.name = ''\n        }\n        else {\n            name = [\n                typeof SETTINGS.hiddenPrefix == 'string' ? SETTINGS.hiddenPrefix : '',\n                typeof SETTINGS.hiddenSuffix == 'string' ? SETTINGS.hiddenSuffix : '_submit'\n            ]\n            name = name[0] + ELEMENT.name + name[1]\n        }\n\n        P._hidden = $(\n            '<input ' +\n            'type=hidden ' +\n\n            // Create the name using the original input’s with a prefix and suffix.\n            'name=\"' + name + '\"' +\n\n            // If the element has a value, set the hidden value as well.\n            (\n                $ELEMENT.data('value') || ELEMENT.value ?\n                    ' value=\"' + P.get('select', SETTINGS.formatSubmit) + '\"' :\n                    ''\n            ) +\n            '>'\n        )[0]\n\n        $ELEMENT.\n\n            // If the value changes, update the hidden input with the correct format.\n            on('change.' + STATE.id, function() {\n                P._hidden.value = ELEMENT.value ?\n                    P.get('select', SETTINGS.formatSubmit) :\n                    ''\n            })\n    }\n\n\n    // Wait for transitions to end before focusing the holder. Otherwise, while\n    // using the `container` option, the view jumps to the container.\n    function focusPickerOnceOpened() {\n\n        if (IS_DEFAULT_THEME && supportsTransitions) {\n            P.$holder.find('.' + CLASSES.frame).one('transitionend', function() {\n                P.$holder[0].focus()\n            })\n        }\n        else {\n            P.$holder[0].focus()\n        }\n    }\n\n\n    function handleFocusToOpenEvent(event) {\n\n        // Stop the event from propagating to the doc.\n        event.stopPropagation()\n\n        // Add the “target” class.\n        $ELEMENT.addClass( CLASSES.target )\n\n        // Add the “focused” class to the root.\n        P.$root.addClass( CLASSES.focused )\n\n        // And then finally open the picker.\n        P.open()\n    }\n\n\n    // For iOS8.\n    function handleKeydownEvent( event ) {\n\n        var keycode = event.keyCode,\n\n            // Check if one of the delete keys was pressed.\n            isKeycodeDelete = /^(8|46)$/.test(keycode)\n\n        // For some reason IE clears the input value on “escape”.\n        if ( keycode == 27 ) {\n            P.close( true )\n            return false\n        }\n\n        // Check if `space` or `delete` was pressed or the picker is closed with a key movement.\n        if ( keycode == 32 || isKeycodeDelete || !STATE.open && P.component.key[keycode] ) {\n\n            // Prevent it from moving the page and bubbling to doc.\n            event.preventDefault()\n            event.stopPropagation()\n\n            // If `delete` was pressed, clear the values and close the picker.\n            // Otherwise open the picker.\n            if ( isKeycodeDelete ) { P.clear().close() }\n            else { P.open() }\n        }\n    }\n\n\n    // Return a new picker instance.\n    return new PickerInstance()\n} //PickerConstructor\n\n\n\n/**\n * The default classes and prefix to use for the HTML classes.\n */\nPickerConstructor.klasses = function( prefix ) {\n    prefix = prefix || 'picker'\n    return {\n\n        picker: prefix,\n        opened: prefix + '--opened',\n        focused: prefix + '--focused',\n\n        input: prefix + '__input',\n        active: prefix + '__input--active',\n        target: prefix + '__input--target',\n\n        holder: prefix + '__holder',\n\n        frame: prefix + '__frame',\n        wrap: prefix + '__wrap',\n\n        box: prefix + '__box'\n    }\n} //PickerConstructor.klasses\n\n\n\n/**\n * Check if the default theme is being used.\n */\nfunction isUsingDefaultTheme( element ) {\n\n    var theme,\n        prop = 'position'\n\n    // For IE.\n    if ( element.currentStyle ) {\n        theme = element.currentStyle[prop]\n    }\n\n    // For normal browsers.\n    else if ( window.getComputedStyle ) {\n        theme = getComputedStyle( element )[prop]\n    }\n\n    return theme == 'fixed'\n}\n\n\n\n/**\n * Get the width of the browser’s scrollbar.\n * Taken from: https://github.com/VodkaBears/Remodal/blob/master/src/jquery.remodal.js\n */\nfunction getScrollbarWidth() {\n\n    if ( $html.height() <= $window.height() ) {\n        return 0\n    }\n\n    var $outer = $( '<div style=\"visibility:hidden;width:100px\" />' ).\n        appendTo( 'body' )\n\n    // Get the width without scrollbars.\n    var widthWithoutScroll = $outer[0].offsetWidth\n\n    // Force adding scrollbars.\n    $outer.css( 'overflow', 'scroll' )\n\n    // Add the inner div.\n    var $inner = $( '<div style=\"width:100%\" />' ).appendTo( $outer )\n\n    // Get the width with scrollbars.\n    var widthWithScroll = $inner[0].offsetWidth\n\n    // Remove the divs.\n    $outer.remove()\n\n    // Return the difference between the widths.\n    return widthWithoutScroll - widthWithScroll\n}\n\n\n\n/**\n * PickerConstructor helper methods.\n */\nPickerConstructor._ = {\n\n    /**\n     * Create a group of nodes. Expects:\n     * `\n        {\n            min:    {Integer},\n            max:    {Integer},\n            i:      {Integer},\n            node:   {String},\n            item:   {Function}\n        }\n     * `\n     */\n    group: function( groupObject ) {\n\n        var\n            // Scope for the looped object\n            loopObjectScope,\n\n            // Create the nodes list\n            nodesList = '',\n\n            // The counter starts from the `min`\n            counter = PickerConstructor._.trigger( groupObject.min, groupObject )\n\n\n        // Loop from the `min` to `max`, incrementing by `i`\n        for ( ; counter <= PickerConstructor._.trigger( groupObject.max, groupObject, [ counter ] ); counter += groupObject.i ) {\n\n            // Trigger the `item` function within scope of the object\n            loopObjectScope = PickerConstructor._.trigger( groupObject.item, groupObject, [ counter ] )\n\n            // Splice the subgroup and create nodes out of the sub nodes\n            nodesList += PickerConstructor._.node(\n                groupObject.node,\n                loopObjectScope[ 0 ],   // the node\n                loopObjectScope[ 1 ],   // the classes\n                loopObjectScope[ 2 ]    // the attributes\n            )\n        }\n\n        // Return the list of nodes\n        return nodesList\n    }, //group\n\n\n    /**\n     * Create a dom node string\n     */\n    node: function( wrapper, item, klass, attribute ) {\n\n        // If the item is false-y, just return an empty string\n        if ( !item ) return ''\n\n        // If the item is an array, do a join\n        item = $.isArray( item ) ? item.join( '' ) : item\n\n        // Check for the class\n        klass = klass ? ' class=\"' + klass + '\"' : ''\n\n        // Check for any attributes\n        attribute = attribute ? ' ' + attribute : ''\n\n        // Return the wrapped item\n        return '<' + wrapper + klass + attribute + '>' + item + '</' + wrapper + '>'\n    }, //node\n\n\n    /**\n     * Lead numbers below 10 with a zero.\n     */\n    lead: function( number ) {\n        return ( number < 10 ? '0': '' ) + number\n    },\n\n\n    /**\n     * Trigger a function otherwise return the value.\n     */\n    trigger: function( callback, scope, args ) {\n        return typeof callback == 'function' ? callback.apply( scope, args || [] ) : callback\n    },\n\n\n    /**\n     * If the second character is a digit, length is 2 otherwise 1.\n     */\n    digits: function( string ) {\n        return ( /\\d/ ).test( string[ 1 ] ) ? 2 : 1\n    },\n\n\n    /**\n     * Tell if something is a date object.\n     */\n    isDate: function( value ) {\n        return {}.toString.call( value ).indexOf( 'Date' ) > -1 && this.isInteger( value.getDate() )\n    },\n\n\n    /**\n     * Tell if something is an integer.\n     */\n    isInteger: function( value ) {\n        return {}.toString.call( value ).indexOf( 'Number' ) > -1 && value % 1 === 0\n    },\n\n\n    /**\n     * Create ARIA attribute strings.\n     */\n    ariaAttr: ariaAttr\n} //PickerConstructor._\n\n\n\n/**\n * Extend the picker with a component and defaults.\n */\nPickerConstructor.extend = function( name, Component ) {\n\n    // Extend jQuery.\n    $.fn[ name ] = function( options, action ) {\n\n        // Grab the component data.\n        var componentData = this.data( name )\n\n        // If the picker is requested, return the data object.\n        if ( options == 'picker' ) {\n            return componentData\n        }\n\n        // If the component data exists and `options` is a string, carry out the action.\n        if ( componentData && typeof options == 'string' ) {\n            return PickerConstructor._.trigger( componentData[ options ], componentData, [ action ] )\n        }\n\n        // Otherwise go through each matched element and if the component\n        // doesn’t exist, create a new picker using `this` element\n        // and merging the defaults and options with a deep copy.\n        return this.each( function() {\n            var $this = $( this )\n            if ( !$this.data( name ) ) {\n                new PickerConstructor( this, name, Component, options )\n            }\n        })\n    }\n\n    // Set the defaults.\n    $.fn[ name ].defaults = Component.defaults\n} //PickerConstructor.extend\n\n\n\nfunction aria(element, attribute, value) {\n    if ( $.isPlainObject(attribute) ) {\n        for ( var key in attribute ) {\n            ariaSet(element, key, attribute[key])\n        }\n    }\n    else {\n        ariaSet(element, attribute, value)\n    }\n}\nfunction ariaSet(element, attribute, value) {\n    element.setAttribute(\n        (attribute == 'role' ? '' : 'aria-') + attribute,\n        value\n    )\n}\nfunction ariaAttr(attribute, data) {\n    if ( !$.isPlainObject(attribute) ) {\n        attribute = { attribute: data }\n    }\n    data = ''\n    for ( var key in attribute ) {\n        var attr = (key == 'role' ? '' : 'aria-') + key,\n            attrVal = attribute[key]\n        data += attrVal == null ? '' : attr + '=\"' + attribute[key] + '\"'\n    }\n    return data\n}\n\n// IE8 bug throws an error for activeElements within iframes.\nfunction getActiveElement() {\n    try {\n        return document.activeElement\n    } catch ( err ) { }\n}\n\n\n\n// Expose the picker constructor.\nreturn PickerConstructor\n\n\n}));\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/pickadate-webpack/lib/picker.js?");

/***/ }),

/***/ "./node_modules/pickadate-webpack/lib/picker.time.js":
/*!***********************************************************!*\
  !*** ./node_modules/pickadate-webpack/lib/picker.time.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Time picker for pickadate.js v3.5.6\n * http://amsul.github.io/pickadate.js/time.htm\n */\n\n(function ( factory ) {\n\n    // Node.js/browserify.\n    if ( true )\n        module.exports = factory( __webpack_require__(/*! ./picker.js */ \"./node_modules/pickadate-webpack/lib/picker.js\"), __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\") )\n\n    // Browser globals.\n    else {}\n\n}(function( Picker, $ ) {\n\n\n/**\n * Globals and constants\n */\nvar HOURS_IN_DAY = 24,\n    MINUTES_IN_HOUR = 60,\n    HOURS_TO_NOON = 12,\n    MINUTES_IN_DAY = HOURS_IN_DAY * MINUTES_IN_HOUR,\n    _ = Picker._\n\n\n\n/**\n * The time picker constructor\n */\nfunction TimePicker( picker, settings ) {\n\n    var clock = this,\n        elementValue = picker.$node[ 0 ].value,\n        elementDataValue = picker.$node.data( 'value' ),\n        valueString = elementDataValue || elementValue,\n        formatString = elementDataValue ? settings.formatSubmit : settings.format\n\n    clock.settings = settings\n    clock.$node = picker.$node\n\n    // The queue of methods that will be used to build item objects.\n    clock.queue = {\n        interval: 'i',\n        min: 'measure create',\n        max: 'measure create',\n        now: 'now create',\n        select: 'parse create validate',\n        highlight: 'parse create validate',\n        view: 'parse create validate',\n        disable: 'deactivate',\n        enable: 'activate'\n    }\n\n    // The component's item object.\n    clock.item = {}\n\n    clock.item.clear = null\n    clock.item.interval = settings.interval || 30\n    clock.item.disable = ( settings.disable || [] ).slice( 0 )\n    clock.item.enable = -(function( collectionDisabled ) {\n        return collectionDisabled[ 0 ] === true ? collectionDisabled.shift() : -1\n    })( clock.item.disable )\n\n    clock.\n        set( 'min', settings.min ).\n        set( 'max', settings.max ).\n        set( 'now' )\n\n    // When there’s a value, set the `select`, which in turn\n    // also sets the `highlight` and `view`.\n    if ( valueString ) {\n        clock.set( 'select', valueString, {\n            format: formatString\n        })\n    }\n\n    // If there’s no value, default to highlighting “today”.\n    else {\n        clock.\n            set( 'select', null ).\n            set( 'highlight', clock.item.now )\n    }\n\n    // The keycode to movement mapping.\n    clock.key = {\n        40: 1, // Down\n        38: -1, // Up\n        39: 1, // Right\n        37: -1, // Left\n        go: function( timeChange ) {\n            clock.set(\n                'highlight',\n                clock.item.highlight.pick + timeChange * clock.item.interval,\n                { interval: timeChange * clock.item.interval }\n            )\n            this.render()\n        }\n    }\n\n\n    // Bind some picker events.\n    picker.\n        on( 'render', function() {\n            var $pickerHolder = picker.$root.children(),\n                $viewset = $pickerHolder.find( '.' + settings.klass.viewset ),\n                vendors = function( prop ) {\n                    return ['webkit', 'moz', 'ms', 'o', ''].map(function( vendor ) {\n                        return ( vendor ? '-' + vendor + '-' : '' ) + prop\n                    })\n                },\n                animations = function( $el, state ) {\n                    vendors( 'transform' ).map(function( prop ) {\n                        $el.css( prop, state )\n                    })\n                    vendors( 'transition' ).map(function( prop ) {\n                        $el.css( prop, state )\n                    })\n                }\n            if ( $viewset.length ) {\n                animations( $pickerHolder, 'none' )\n                $pickerHolder[ 0 ].scrollTop = ~~$viewset.position().top - ( $viewset[ 0 ].clientHeight * 2 )\n                animations( $pickerHolder, '' )\n            }\n        }, 1 ).\n        on( 'open', function() {\n            picker.$root.find( 'button' ).attr( 'disabled', false )\n        }, 1 ).\n        on( 'close', function() {\n            picker.$root.find( 'button' ).attr( 'disabled', true )\n        }, 1 )\n\n} //TimePicker\n\n\n/**\n * Set a timepicker item object.\n */\nTimePicker.prototype.set = function( type, value, options ) {\n\n    var clock = this,\n        clockItem = clock.item\n\n    // If the value is `null` just set it immediately.\n    if ( value === null ) {\n        if ( type == 'clear' ) type = 'select'\n        clockItem[ type ] = value\n        return clock\n    }\n\n    // Otherwise go through the queue of methods, and invoke the functions.\n    // Update this as the time unit, and set the final value as this item.\n    // * In the case of `enable`, keep the queue but set `disable` instead.\n    //   And in the case of `flip`, keep the queue but set `enable` instead.\n    clockItem[ ( type == 'enable' ? 'disable' : type == 'flip' ? 'enable' : type ) ] = clock.queue[ type ].split( ' ' ).map( function( method ) {\n        value = clock[ method ]( type, value, options )\n        return value\n    }).pop()\n\n    // Check if we need to cascade through more updates.\n    if ( type == 'select' ) {\n        clock.set( 'highlight', clockItem.select, options )\n    }\n    else if ( type == 'highlight' ) {\n        clock.set( 'view', clockItem.highlight, options )\n    }\n    else if ( type == 'interval' ) {\n        clock.\n            set( 'min', clockItem.min, options ).\n            set( 'max', clockItem.max, options )\n    }\n    else if ( type.match( /^(flip|min|max|disable|enable)$/ ) ) {\n        if ( clockItem.select && clock.disabled( clockItem.select ) ) {\n            clock.set( 'select', value, options )\n        }\n        if ( clockItem.highlight && clock.disabled( clockItem.highlight ) ) {\n            clock.set( 'highlight', value, options )\n        }\n        if ( type == 'min' ) {\n            clock.set( 'max', clockItem.max, options )\n        }\n    }\n\n    return clock\n} //TimePicker.prototype.set\n\n\n/**\n * Get a timepicker item object.\n */\nTimePicker.prototype.get = function( type ) {\n    return this.item[ type ]\n} //TimePicker.prototype.get\n\n\n/**\n * Create a picker time object.\n */\nTimePicker.prototype.create = function( type, value, options ) {\n\n    var clock = this\n\n    // If there’s no value, use the type as the value.\n    value = value === undefined ? type : value\n\n    // If it’s a date object, convert it into an array.\n    if ( _.isDate( value ) ) {\n        value = [ value.getHours(), value.getMinutes() ]\n    }\n\n    // If it’s an object, use the “pick” value.\n    if ( $.isPlainObject( value ) && _.isInteger( value.pick ) ) {\n        value = value.pick\n    }\n\n    // If it’s an array, convert it into minutes.\n    else if ( $.isArray( value ) ) {\n        value = +value[ 0 ] * MINUTES_IN_HOUR + (+value[ 1 ])\n    }\n\n    // If no valid value is passed, set it to “now”.\n    else if ( !_.isInteger( value ) ) {\n        value = clock.now( type, value, options )\n    }\n\n    // If we’re setting the max, make sure it’s greater than the min.\n    if ( type == 'max' && value < clock.item.min.pick ) {\n        value += MINUTES_IN_DAY\n    }\n\n    // If the value doesn’t fall directly on the interval,\n    // add one interval to indicate it as “passed”.\n    if ( type != 'min' && type != 'max' && (value - clock.item.min.pick) % clock.item.interval !== 0 ) {\n        value += clock.item.interval\n    }\n\n    // Normalize it into a “reachable” interval.\n    value = clock.normalize( type, value, options )\n\n    // Return the compiled object.\n    return {\n\n        // Divide to get hours from minutes.\n        hour: ~~( HOURS_IN_DAY + value / MINUTES_IN_HOUR ) % HOURS_IN_DAY,\n\n        // The remainder is the minutes.\n        mins: ( MINUTES_IN_HOUR + value % MINUTES_IN_HOUR ) % MINUTES_IN_HOUR,\n\n        // The time in total minutes.\n        time: ( MINUTES_IN_DAY + value ) % MINUTES_IN_DAY,\n\n        // Reference to the “relative” value to pick.\n        pick: value % MINUTES_IN_DAY\n    }\n} //TimePicker.prototype.create\n\n\n/**\n * Create a range limit object using an array, date object,\n * literal “true”, or integer relative to another time.\n */\nTimePicker.prototype.createRange = function( from, to ) {\n\n    var clock = this,\n        createTime = function( time ) {\n            if ( time === true || $.isArray( time ) || _.isDate( time ) ) {\n                return clock.create( time )\n            }\n            return time\n        }\n\n    // Create objects if possible.\n    if ( !_.isInteger( from ) ) {\n        from = createTime( from )\n    }\n    if ( !_.isInteger( to ) ) {\n        to = createTime( to )\n    }\n\n    // Create relative times.\n    if ( _.isInteger( from ) && $.isPlainObject( to ) ) {\n        from = [ to.hour, to.mins + ( from * clock.settings.interval ) ];\n    }\n    else if ( _.isInteger( to ) && $.isPlainObject( from ) ) {\n        to = [ from.hour, from.mins + ( to * clock.settings.interval ) ];\n    }\n\n    return {\n        from: createTime( from ),\n        to: createTime( to )\n    }\n} //TimePicker.prototype.createRange\n\n\n/**\n * Check if a time unit falls within a time range object.\n */\nTimePicker.prototype.withinRange = function( range, timeUnit ) {\n    range = this.createRange(range.from, range.to)\n    return timeUnit.pick >= range.from.pick && timeUnit.pick <= range.to.pick\n}\n\n\n/**\n * Check if two time range objects overlap.\n */\nTimePicker.prototype.overlapRanges = function( one, two ) {\n\n    var clock = this\n\n    // Convert the ranges into comparable times.\n    one = clock.createRange( one.from, one.to )\n    two = clock.createRange( two.from, two.to )\n\n    return clock.withinRange( one, two.from ) || clock.withinRange( one, two.to ) ||\n        clock.withinRange( two, one.from ) || clock.withinRange( two, one.to )\n}\n\n\n/**\n * Get the time relative to now.\n */\nTimePicker.prototype.now = function( type, value/*, options*/ ) {\n\n    var interval = this.item.interval,\n        date = new Date(),\n        nowMinutes = date.getHours() * MINUTES_IN_HOUR + date.getMinutes(),\n        isValueInteger = _.isInteger( value ),\n        isBelowInterval\n\n    // Make sure “now” falls within the interval range.\n    nowMinutes -= nowMinutes % interval\n\n    // Check if the difference is less than the interval itself.\n    isBelowInterval = value < 0 && interval * value + nowMinutes <= -interval\n\n    // Add an interval because the time has “passed”.\n    nowMinutes += type == 'min' && isBelowInterval ? 0 : interval\n\n    // If the value is a number, adjust by that many intervals.\n    if ( isValueInteger ) {\n        nowMinutes += interval * (\n            isBelowInterval && type != 'max' ?\n                value + 1 :\n                value\n            )\n    }\n\n    // Return the final calculation.\n    return nowMinutes\n} //TimePicker.prototype.now\n\n\n/**\n * Normalize minutes to be “reachable” based on the min and interval.\n */\nTimePicker.prototype.normalize = function( type, value/*, options*/ ) {\n\n    var interval = this.item.interval,\n        minTime = this.item.min && this.item.min.pick || 0\n\n    // If setting min time, don’t shift anything.\n    // Otherwise get the value and min difference and then\n    // normalize the difference with the interval.\n    value -= type == 'min' ? 0 : ( value - minTime ) % interval\n\n    // Return the adjusted value.\n    return value\n} //TimePicker.prototype.normalize\n\n\n/**\n * Measure the range of minutes.\n */\nTimePicker.prototype.measure = function( type, value, options ) {\n\n    var clock = this\n\n    // If it’s anything false-y, set it to the default.\n    if ( !value ) {\n        value = type == 'min' ? [ 0, 0 ] : [ HOURS_IN_DAY - 1, MINUTES_IN_HOUR - 1 ]\n    }\n\n    // If it’s a string, parse it.\n    if ( typeof value == 'string' ) {\n        value = clock.parse( type, value )\n    }\n\n    // If it’s a literal true, or an integer, make it relative to now.\n    else if ( value === true || _.isInteger( value ) ) {\n        value = clock.now( type, value, options )\n    }\n\n    // If it’s an object already, just normalize it.\n    else if ( $.isPlainObject( value ) && _.isInteger( value.pick ) ) {\n        value = clock.normalize( type, value.pick, options )\n    }\n\n    return value\n} ///TimePicker.prototype.measure\n\n\n/**\n * Validate an object as enabled.\n */\nTimePicker.prototype.validate = function( type, timeObject, options ) {\n\n    var clock = this,\n        interval = options && options.interval ? options.interval : clock.item.interval\n\n    // Check if the object is disabled.\n    if ( clock.disabled( timeObject ) ) {\n\n        // Shift with the interval until we reach an enabled time.\n        timeObject = clock.shift( timeObject, interval )\n    }\n\n    // Scope the object into range.\n    timeObject = clock.scope( timeObject )\n\n    // Do a second check to see if we landed on a disabled min/max.\n    // In that case, shift using the opposite interval as before.\n    if ( clock.disabled( timeObject ) ) {\n        timeObject = clock.shift( timeObject, interval * -1 )\n    }\n\n    // Return the final object.\n    return timeObject\n} //TimePicker.prototype.validate\n\n\n/**\n * Check if an object is disabled.\n */\nTimePicker.prototype.disabled = function( timeToVerify ) {\n\n    var clock = this,\n\n        // Filter through the disabled times to check if this is one.\n        isDisabledMatch = clock.item.disable.filter( function( timeToDisable ) {\n\n            // If the time is a number, match the hours.\n            if ( _.isInteger( timeToDisable ) ) {\n                return timeToVerify.hour == timeToDisable\n            }\n\n            // If it’s an array, create the object and match the times.\n            if ( $.isArray( timeToDisable ) || _.isDate( timeToDisable ) ) {\n                return timeToVerify.pick == clock.create( timeToDisable ).pick\n            }\n\n            // If it’s an object, match a time within the “from” and “to” range.\n            if ( $.isPlainObject( timeToDisable ) ) {\n                return clock.withinRange( timeToDisable, timeToVerify )\n            }\n        })\n\n    // If this time matches a disabled time, confirm it’s not inverted.\n    isDisabledMatch = isDisabledMatch.length && !isDisabledMatch.filter(function( timeToDisable ) {\n        return $.isArray( timeToDisable ) && timeToDisable[2] == 'inverted' ||\n            $.isPlainObject( timeToDisable ) && timeToDisable.inverted\n    }).length\n\n    // If the clock is \"enabled\" flag is flipped, flip the condition.\n    return clock.item.enable === -1 ? !isDisabledMatch : isDisabledMatch ||\n        timeToVerify.pick < clock.item.min.pick ||\n        timeToVerify.pick > clock.item.max.pick\n} //TimePicker.prototype.disabled\n\n\n/**\n * Shift an object by an interval until we reach an enabled object.\n */\nTimePicker.prototype.shift = function( timeObject, interval ) {\n\n    var clock = this,\n        minLimit = clock.item.min.pick,\n        maxLimit = clock.item.max.pick/*,\n        safety = 1000*/\n\n    interval = interval || clock.item.interval\n\n    // Keep looping as long as the time is disabled.\n    while ( /*safety &&*/ clock.disabled( timeObject ) ) {\n\n        /*safety -= 1\n        if ( !safety ) {\n            throw 'Fell into an infinite loop while shifting to ' + timeObject.hour + ':' + timeObject.mins + '.'\n        }*/\n\n        // Increase/decrease the time by the interval and keep looping.\n        timeObject = clock.create( timeObject.pick += interval )\n\n        // If we've looped beyond the limits, break out of the loop.\n        if ( timeObject.pick <= minLimit || timeObject.pick >= maxLimit ) {\n            break\n        }\n    }\n\n    // Return the final object.\n    return timeObject\n} //TimePicker.prototype.shift\n\n\n/**\n * Scope an object to be within range of min and max.\n */\nTimePicker.prototype.scope = function( timeObject ) {\n    var minLimit = this.item.min.pick,\n        maxLimit = this.item.max.pick\n    return this.create( timeObject.pick > maxLimit ? maxLimit : timeObject.pick < minLimit ? minLimit : timeObject )\n} //TimePicker.prototype.scope\n\n\n/**\n * Parse a string into a usable type.\n */\nTimePicker.prototype.parse = function( type, value, options ) {\n\n    var hour, minutes, isPM, item, parseValue,\n        clock = this,\n        parsingObject = {}\n\n    // If it’s already parsed, we’re good.\n    if ( !value || typeof value != 'string' ) {\n        return value\n    }\n\n    // We need a `.format` to parse the value with.\n    if ( !( options && options.format ) ) {\n        options = options || {}\n        options.format = clock.settings.format\n    }\n\n    // Convert the format into an array and then map through it.\n    clock.formats.toArray( options.format ).map( function( label ) {\n\n        var\n            substring,\n\n            // Grab the formatting label.\n            formattingLabel = clock.formats[ label ],\n\n            // The format length is from the formatting label function or the\n            // label length without the escaping exclamation (!) mark.\n            formatLength = formattingLabel ?\n                _.trigger( formattingLabel, clock, [ value, parsingObject ] ) :\n                label.replace( /^!/, '' ).length\n\n        // If there's a format label, split the value up to the format length.\n        // Then add it to the parsing object with appropriate label.\n        if ( formattingLabel ) {\n            substring = value.substr( 0, formatLength )\n            parsingObject[ label ] = substring.match(/^\\d+$/) ? +substring : substring\n        }\n\n        // Update the time value as the substring from format length to end.\n        value = value.substr( formatLength )\n    })\n\n    // Grab the hour and minutes from the parsing object.\n    for ( item in parsingObject ) {\n        parseValue = parsingObject[item]\n        if ( _.isInteger(parseValue) ) {\n            if ( item.match(/^(h|hh)$/i) ) {\n                hour = parseValue\n                if ( item == 'h' || item == 'hh' ) {\n                    hour %= 12\n                }\n            }\n            else if ( item == 'i' ) {\n                minutes = parseValue\n            }\n        }\n        else if ( item.match(/^a$/i) && parseValue.match(/^p/i) && ('h' in parsingObject || 'hh' in parsingObject) ) {\n            isPM = true\n        }\n    }\n\n    // Calculate it in minutes and return.\n    return (isPM ? hour + 12 : hour) * MINUTES_IN_HOUR + minutes\n} //TimePicker.prototype.parse\n\n\n/**\n * Various formats to display the object in.\n */\nTimePicker.prototype.formats = {\n\n    h: function( string, timeObject ) {\n\n        // If there's string, then get the digits length.\n        // Otherwise return the selected hour in \"standard\" format.\n        return string ? _.digits( string ) : timeObject.hour % HOURS_TO_NOON || HOURS_TO_NOON\n    },\n    hh: function( string, timeObject ) {\n\n        // If there's a string, then the length is always 2.\n        // Otherwise return the selected hour in \"standard\" format with a leading zero.\n        return string ? 2 : _.lead( timeObject.hour % HOURS_TO_NOON || HOURS_TO_NOON )\n    },\n    H: function( string, timeObject ) {\n\n        // If there's string, then get the digits length.\n        // Otherwise return the selected hour in \"military\" format as a string.\n        return string ? _.digits( string ) : '' + ( timeObject.hour % 24 )\n    },\n    HH: function( string, timeObject ) {\n\n        // If there's string, then get the digits length.\n        // Otherwise return the selected hour in \"military\" format with a leading zero.\n        return string ? _.digits( string ) : _.lead( timeObject.hour % 24 )\n    },\n    i: function( string, timeObject ) {\n\n        // If there's a string, then the length is always 2.\n        // Otherwise return the selected minutes.\n        return string ? 2 : _.lead( timeObject.mins )\n    },\n    a: function( string, timeObject ) {\n\n        // If there's a string, then the length is always 4.\n        // Otherwise check if it's more than \"noon\" and return either am/pm.\n        return string ? 4 : MINUTES_IN_DAY / 2 > timeObject.time % MINUTES_IN_DAY ? 'a.m.' : 'p.m.'\n    },\n    A: function( string, timeObject ) {\n\n        // If there's a string, then the length is always 2.\n        // Otherwise check if it's more than \"noon\" and return either am/pm.\n        return string ? 2 : MINUTES_IN_DAY / 2 > timeObject.time % MINUTES_IN_DAY ? 'AM' : 'PM'\n    },\n\n    // Create an array by splitting the formatting string passed.\n    toArray: function( formatString ) { return formatString.split( /(h{1,2}|H{1,2}|i|a|A|!.)/g ) },\n\n    // Format an object into a string using the formatting options.\n    toString: function ( formatString, itemObject ) {\n        var clock = this\n        return clock.formats.toArray( formatString ).map( function( label ) {\n            return _.trigger( clock.formats[ label ], clock, [ 0, itemObject ] ) || label.replace( /^!/, '' )\n        }).join( '' )\n    }\n} //TimePicker.prototype.formats\n\n\n\n\n/**\n * Check if two time units are the exact.\n */\nTimePicker.prototype.isTimeExact = function( one, two ) {\n\n    var clock = this\n\n    // When we’re working with minutes, do a direct comparison.\n    if (\n        ( _.isInteger( one ) && _.isInteger( two ) ) ||\n        ( typeof one == 'boolean' && typeof two == 'boolean' )\n     ) {\n        return one === two\n    }\n\n    // When we’re working with time representations, compare the “pick” value.\n    if (\n        ( _.isDate( one ) || $.isArray( one ) ) &&\n        ( _.isDate( two ) || $.isArray( two ) )\n    ) {\n        return clock.create( one ).pick === clock.create( two ).pick\n    }\n\n    // When we’re working with range objects, compare the “from” and “to”.\n    if ( $.isPlainObject( one ) && $.isPlainObject( two ) ) {\n        return clock.isTimeExact( one.from, two.from ) && clock.isTimeExact( one.to, two.to )\n    }\n\n    return false\n}\n\n\n/**\n * Check if two time units overlap.\n */\nTimePicker.prototype.isTimeOverlap = function( one, two ) {\n\n    var clock = this\n\n    // When we’re working with an integer, compare the hours.\n    if ( _.isInteger( one ) && ( _.isDate( two ) || $.isArray( two ) ) ) {\n        return one === clock.create( two ).hour\n    }\n    if ( _.isInteger( two ) && ( _.isDate( one ) || $.isArray( one ) ) ) {\n        return two === clock.create( one ).hour\n    }\n\n    // When we’re working with range objects, check if the ranges overlap.\n    if ( $.isPlainObject( one ) && $.isPlainObject( two ) ) {\n        return clock.overlapRanges( one, two )\n    }\n\n    return false\n}\n\n\n/**\n * Flip the “enabled” state.\n */\nTimePicker.prototype.flipEnable = function(val) {\n    var itemObject = this.item\n    itemObject.enable = val || (itemObject.enable == -1 ? 1 : -1)\n}\n\n\n/**\n * Mark a collection of times as “disabled”.\n */\nTimePicker.prototype.deactivate = function( type, timesToDisable ) {\n\n    var clock = this,\n        disabledItems = clock.item.disable.slice(0)\n\n\n    // If we’re flipping, that’s all we need to do.\n    if ( timesToDisable == 'flip' ) {\n        clock.flipEnable()\n    }\n\n    else if ( timesToDisable === false ) {\n        clock.flipEnable(1)\n        disabledItems = []\n    }\n\n    else if ( timesToDisable === true ) {\n        clock.flipEnable(-1)\n        disabledItems = []\n    }\n\n    // Otherwise go through the times to disable.\n    else {\n\n        timesToDisable.map(function( unitToDisable ) {\n\n            var matchFound\n\n            // When we have disabled items, check for matches.\n            // If something is matched, immediately break out.\n            for ( var index = 0; index < disabledItems.length; index += 1 ) {\n                if ( clock.isTimeExact( unitToDisable, disabledItems[index] ) ) {\n                    matchFound = true\n                    break\n                }\n            }\n\n            // If nothing was found, add the validated unit to the collection.\n            if ( !matchFound ) {\n                if (\n                    _.isInteger( unitToDisable ) ||\n                    _.isDate( unitToDisable ) ||\n                    $.isArray( unitToDisable ) ||\n                    ( $.isPlainObject( unitToDisable ) && unitToDisable.from && unitToDisable.to )\n                ) {\n                    disabledItems.push( unitToDisable )\n                }\n            }\n        })\n    }\n\n    // Return the updated collection.\n    return disabledItems\n} //TimePicker.prototype.deactivate\n\n\n/**\n * Mark a collection of times as “enabled”.\n */\nTimePicker.prototype.activate = function( type, timesToEnable ) {\n\n    var clock = this,\n        disabledItems = clock.item.disable,\n        disabledItemsCount = disabledItems.length\n\n    // If we’re flipping, that’s all we need to do.\n    if ( timesToEnable == 'flip' ) {\n        clock.flipEnable()\n    }\n\n    else if ( timesToEnable === true ) {\n        clock.flipEnable(1)\n        disabledItems = []\n    }\n\n    else if ( timesToEnable === false ) {\n        clock.flipEnable(-1)\n        disabledItems = []\n    }\n\n    // Otherwise go through the disabled times.\n    else {\n\n        timesToEnable.map(function( unitToEnable ) {\n\n            var matchFound,\n                disabledUnit,\n                index,\n                isRangeMatched\n\n            // Go through the disabled items and try to find a match.\n            for ( index = 0; index < disabledItemsCount; index += 1 ) {\n\n                disabledUnit = disabledItems[index]\n\n                // When an exact match is found, remove it from the collection.\n                if ( clock.isTimeExact( disabledUnit, unitToEnable ) ) {\n                    matchFound = disabledItems[index] = null\n                    isRangeMatched = true\n                    break\n                }\n\n                // When an overlapped match is found, add the “inverted” state to it.\n                else if ( clock.isTimeOverlap( disabledUnit, unitToEnable ) ) {\n                    if ( $.isPlainObject( unitToEnable ) ) {\n                        unitToEnable.inverted = true\n                        matchFound = unitToEnable\n                    }\n                    else if ( $.isArray( unitToEnable ) ) {\n                        matchFound = unitToEnable\n                        if ( !matchFound[2] ) matchFound.push( 'inverted' )\n                    }\n                    else if ( _.isDate( unitToEnable ) ) {\n                        matchFound = [ unitToEnable.getFullYear(), unitToEnable.getMonth(), unitToEnable.getDate(), 'inverted' ]\n                    }\n                    break\n                }\n            }\n\n            // If a match was found, remove a previous duplicate entry.\n            if ( matchFound ) for ( index = 0; index < disabledItemsCount; index += 1 ) {\n                if ( clock.isTimeExact( disabledItems[index], unitToEnable ) ) {\n                    disabledItems[index] = null\n                    break\n                }\n            }\n\n            // In the event that we’re dealing with an overlap of range times,\n            // make sure there are no “inverted” times because of it.\n            if ( isRangeMatched ) for ( index = 0; index < disabledItemsCount; index += 1 ) {\n                if ( clock.isTimeOverlap( disabledItems[index], unitToEnable ) ) {\n                    disabledItems[index] = null\n                    break\n                }\n            }\n\n            // If something is still matched, add it into the collection.\n            if ( matchFound ) {\n                disabledItems.push( matchFound )\n            }\n        })\n    }\n\n    // Return the updated collection.\n    return disabledItems.filter(function( val ) { return val != null })\n} //TimePicker.prototype.activate\n\n\n/**\n * The division to use for the range intervals.\n */\nTimePicker.prototype.i = function( type, value/*, options*/ ) {\n    return _.isInteger( value ) && value > 0 ? value : this.item.interval\n}\n\n\n/**\n * Create a string for the nodes in the picker.\n */\nTimePicker.prototype.nodes = function( isOpen ) {\n\n    var\n        clock = this,\n        settings = clock.settings,\n        selectedObject = clock.item.select,\n        highlightedObject = clock.item.highlight,\n        viewsetObject = clock.item.view,\n        disabledCollection = clock.item.disable\n\n    return _.node(\n        'ul',\n        _.group({\n            min: clock.item.min.pick,\n            max: clock.item.max.pick,\n            i: clock.item.interval,\n            node: 'li',\n            item: function( loopedTime ) {\n                loopedTime = clock.create( loopedTime )\n                var timeMinutes = loopedTime.pick,\n                    isSelected = selectedObject && selectedObject.pick == timeMinutes,\n                    isHighlighted = highlightedObject && highlightedObject.pick == timeMinutes,\n                    isDisabled = disabledCollection && clock.disabled( loopedTime ),\n                    formattedTime = _.trigger( clock.formats.toString, clock, [ settings.format, loopedTime ] )\n                return [\n                    _.trigger( clock.formats.toString, clock, [ _.trigger( settings.formatLabel, clock, [ loopedTime ] ) || settings.format, loopedTime ] ),\n                    (function( klasses ) {\n\n                        if ( isSelected ) {\n                            klasses.push( settings.klass.selected )\n                        }\n\n                        if ( isHighlighted ) {\n                            klasses.push( settings.klass.highlighted )\n                        }\n\n                        if ( viewsetObject && viewsetObject.pick == timeMinutes ) {\n                            klasses.push( settings.klass.viewset )\n                        }\n\n                        if ( isDisabled ) {\n                            klasses.push( settings.klass.disabled )\n                        }\n\n                        return klasses.join( ' ' )\n                    })( [ settings.klass.listItem ] ),\n                    'data-pick=' + loopedTime.pick + ' ' + _.ariaAttr({\n                        role: 'option',\n                        label: formattedTime,\n                        selected: isSelected && clock.$node.val() === formattedTime ? true : null,\n                        activedescendant: isHighlighted ? true : null,\n                        disabled: isDisabled ? true : null\n                    })\n                ]\n            }\n        }) +\n\n        // * For Firefox forms to submit, make sure to set the button’s `type` attribute as “button”.\n        _.node(\n            'li',\n            _.node(\n                'button',\n                settings.clear,\n                settings.klass.buttonClear,\n                'type=button data-clear=1' + ( isOpen ? '' : ' disabled' ) + ' ' +\n                _.ariaAttr({ controls: clock.$node[0].id })\n            ),\n            '', _.ariaAttr({ role: 'presentation' })\n        ),\n        settings.klass.list,\n        _.ariaAttr({ role: 'listbox', controls: clock.$node[0].id })\n    )\n} //TimePicker.prototype.nodes\n\n\n\n\n\n\n\n/**\n * Extend the picker to add the component with the defaults.\n */\nTimePicker.defaults = (function( prefix ) {\n\n    return {\n\n        // Clear\n        clear: 'Clear',\n\n        // The format to show on the `input` element\n        format: 'h:i A',\n\n        // The interval between each time\n        interval: 30,\n\n        // Picker close behavior\n        closeOnSelect: true,\n        closeOnClear: true,\n\n        // Classes\n        klass: {\n\n            picker: prefix + ' ' + prefix + '--time',\n            holder: prefix + '__holder',\n\n            list: prefix + '__list',\n            listItem: prefix + '__list-item',\n\n            disabled: prefix + '__list-item--disabled',\n            selected: prefix + '__list-item--selected',\n            highlighted: prefix + '__list-item--highlighted',\n            viewset: prefix + '__list-item--viewset',\n            now: prefix + '__list-item--now',\n\n            buttonClear: prefix + '__button--clear'\n        }\n    }\n})( Picker.klasses().picker )\n\n\n\n\n\n/**\n * Extend the picker to add the time picker.\n */\nPicker.extend( 'pickatime', TimePicker )\n\n\n}));\n\n\n\n\n\n//# sourceURL=webpack:///./node_modules/pickadate-webpack/lib/picker.time.js?");

/***/ }),

/***/ "./node_modules/trumbowyg/dist/trumbowyg.min.js":
/*!******************************************************!*\
  !*** ./node_modules/trumbowyg/dist/trumbowyg.min.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(jQuery) {/** Trumbowyg v2.19.1 - A lightweight WYSIWYG editor - alex-d.github.io/Trumbowyg - License MIT - Author : Alexandre Demode (Alex-D) / alex-d.fr */\njQuery.trumbowyg={langs:{en:{viewHTML:\"View HTML\",undo:\"Undo\",redo:\"Redo\",formatting:\"Formatting\",p:\"Paragraph\",blockquote:\"Quote\",code:\"Code\",header:\"Header\",bold:\"Bold\",italic:\"Italic\",strikethrough:\"Strikethrough\",underline:\"Underline\",strong:\"Strong\",em:\"Emphasis\",del:\"Deleted\",superscript:\"Superscript\",subscript:\"Subscript\",unorderedList:\"Unordered list\",orderedList:\"Ordered list\",insertImage:\"Insert Image\",link:\"Link\",createLink:\"Insert link\",unlink:\"Remove link\",justifyLeft:\"Align Left\",justifyCenter:\"Align Center\",justifyRight:\"Align Right\",justifyFull:\"Align Justify\",horizontalRule:\"Insert horizontal rule\",removeformat:\"Remove format\",fullscreen:\"Fullscreen\",close:\"Close\",submit:\"Confirm\",reset:\"Cancel\",required:\"Required\",description:\"Description\",title:\"Title\",text:\"Text\",target:\"Target\",width:\"Width\"}},plugins:{},svgPath:null,hideButtonTexts:null},Object.defineProperty(jQuery.trumbowyg,\"defaultOptions\",{value:{lang:\"en\",fixedBtnPane:!1,fixedFullWidth:!1,autogrow:!1,autogrowOnEnter:!1,imageWidthModalEdit:!1,prefix:\"trumbowyg-\",semantic:!0,semanticKeepAttributes:!1,resetCss:!1,removeformatPasted:!1,tabToIndent:!1,tagsToRemove:[],tagsToKeep:[\"hr\",\"img\",\"embed\",\"iframe\",\"input\"],btns:[[\"viewHTML\"],[\"undo\",\"redo\"],[\"formatting\"],[\"strong\",\"em\",\"del\"],[\"superscript\",\"subscript\"],[\"link\"],[\"insertImage\"],[\"justifyLeft\",\"justifyCenter\",\"justifyRight\",\"justifyFull\"],[\"unorderedList\",\"orderedList\"],[\"horizontalRule\"],[\"removeformat\"],[\"fullscreen\"]],btnsDef:{},changeActiveDropdownIcon:!1,inlineElementsSelector:\"a,abbr,acronym,b,caption,cite,code,col,dfn,dir,dt,dd,em,font,hr,i,kbd,li,q,span,strikeout,strong,sub,sup,u\",pasteHandlers:[],plugins:{},urlProtocol:!1,minimalLinks:!1},writable:!1,enumerable:!0,configurable:!1}),function(e,t,n,a){\"use strict\";var o=\"tbwconfirm\",r=\"tbwcancel\";a.fn.trumbowyg=function(e,t){var n=\"trumbowyg\";if(e===Object(e)||!e)return this.each(function(){a(this).data(n)||a(this).data(n,new i(this,e))});if(1===this.length)try{var o=a(this).data(n);switch(e){case\"execCmd\":return o.execCmd(t.cmd,t.param,t.forceCss,t.skipTrumbowyg);case\"openModal\":return o.openModal(t.title,t.content);case\"closeModal\":return o.closeModal();case\"openModalInsert\":return o.openModalInsert(t.title,t.fields,t.callback);case\"saveRange\":return o.saveRange();case\"getRange\":return o.range;case\"getRangeText\":return o.getRangeText();case\"restoreRange\":return o.restoreRange();case\"enable\":return o.setDisabled(!1);case\"disable\":return o.setDisabled(!0);case\"toggle\":return o.toggle();case\"destroy\":return o.destroy();case\"empty\":return o.empty();case\"html\":return o.html(t)}}catch(r){}return!1};var i=function(o,r){var i=this,s=\"trumbowyg-icons\",l=a.trumbowyg;i.doc=o.ownerDocument||n,i.$ta=a(o),i.$c=a(o),r=r||{},null!=r.lang||null!=l.langs[r.lang]?i.lang=a.extend(!0,{},l.langs.en,l.langs[r.lang]):i.lang=l.langs.en,i.hideButtonTexts=null!=l.hideButtonTexts?l.hideButtonTexts:r.hideButtonTexts;var d=null!=l.svgPath?l.svgPath:r.svgPath;if(i.hasSvg=d!==!1,i.svgPath=i.doc.querySelector(\"base\")?t.location.href.split(\"#\")[0]:\"\",0===a(\"#\"+s,i.doc).length&&d!==!1){if(null==d){for(var c=n.getElementsByTagName(\"script\"),u=0;u<c.length;u+=1){var g=c[u].src,f=g.match(\"trumbowyg(.min)?.js\");null!=f&&(d=g.substring(0,g.indexOf(f[0]))+\"ui/icons.svg\")}null==d&&console.warn(\"You must define svgPath: https://goo.gl/CfTY9U\")}var h=i.doc.createElement(\"div\");h.id=s,i.doc.body.insertBefore(h,i.doc.body.childNodes[0]),a.ajax({async:!0,type:\"GET\",contentType:\"application/x-www-form-urlencoded; charset=UTF-8\",dataType:\"xml\",crossDomain:!0,url:d,data:null,beforeSend:null,complete:null,success:function(e){h.innerHTML=(new XMLSerializer).serializeToString(e.documentElement)}})}var p=i.lang.header,m=function(){return(t.chrome||t.Intl&&Intl.v8BreakIterator)&&\"CSS\"in t};i.btnsDef={viewHTML:{fn:\"toggle\",\"class\":\"trumbowyg-not-disable\"},undo:{isSupported:m,key:\"Z\"},redo:{isSupported:m,key:\"Y\"},p:{fn:\"formatBlock\"},blockquote:{fn:\"formatBlock\"},h1:{fn:\"formatBlock\",title:p+\" 1\"},h2:{fn:\"formatBlock\",title:p+\" 2\"},h3:{fn:\"formatBlock\",title:p+\" 3\"},h4:{fn:\"formatBlock\",title:p+\" 4\"},h5:{fn:\"formatBlock\",title:p+\" 5\"},h6:{fn:\"formatBlock\",title:p+\" 6\"},subscript:{tag:\"sub\"},superscript:{tag:\"sup\"},bold:{key:\"B\",tag:\"b\"},italic:{key:\"I\",tag:\"i\"},underline:{tag:\"u\"},strikethrough:{tag:\"strike\"},strong:{fn:\"bold\",key:\"B\"},em:{fn:\"italic\",key:\"I\"},del:{fn:\"strikethrough\"},createLink:{key:\"K\",tag:\"a\"},unlink:{},insertImage:{},justifyLeft:{tag:\"left\",forceCss:!0},justifyCenter:{tag:\"center\",forceCss:!0},justifyRight:{tag:\"right\",forceCss:!0},justifyFull:{tag:\"justify\",forceCss:!0},unorderedList:{fn:\"insertUnorderedList\",tag:\"ul\"},orderedList:{fn:\"insertOrderedList\",tag:\"ol\"},horizontalRule:{fn:\"insertHorizontalRule\"},removeformat:{},fullscreen:{\"class\":\"trumbowyg-not-disable\"},close:{fn:\"destroy\",\"class\":\"trumbowyg-not-disable\"},formatting:{dropdown:[\"p\",\"blockquote\",\"h1\",\"h2\",\"h3\",\"h4\"],ico:\"p\"},link:{dropdown:[\"createLink\",\"unlink\"]}},i.o=a.extend(!0,{},l.defaultOptions,r),i.o.hasOwnProperty(\"imgDblClickHandler\")||(i.o.imgDblClickHandler=i.getDefaultImgDblClickHandler()),i.urlPrefix=i.setupUrlPrefix(),i.disabled=i.o.disabled||\"TEXTAREA\"===o.nodeName&&o.disabled,r.btns?i.o.btns=r.btns:i.o.semantic||(i.o.btns[3]=[\"bold\",\"italic\",\"underline\",\"strikethrough\"]),a.each(i.o.btnsDef,function(e,t){i.addBtnDef(e,t)}),i.eventNamespace=\"trumbowyg-event\",i.keys=[],i.tagToButton={},i.tagHandlers=[],i.pasteHandlers=[].concat(i.o.pasteHandlers),i.isIE=e.userAgent.indexOf(\"MSIE\")!==-1||e.appVersion.indexOf(\"Trident/\")!==-1,i.isMac=e.platform.toUpperCase().indexOf(\"MAC\")!==-1,i.init()};i.prototype={DEFAULT_SEMANTIC_MAP:{b:\"strong\",i:\"em\",s:\"del\",strike:\"del\",div:\"p\"},init:function(){var e=this;e.height=e.$ta.height(),e.initPlugins();try{e.doc.execCommand(\"enableObjectResizing\",!1,!1),e.doc.execCommand(\"defaultParagraphSeparator\",!1,\"p\")}catch(t){}e.buildEditor(),e.buildBtnPane(),e.fixedBtnPaneEvents(),e.buildOverlay(),setTimeout(function(){e.disabled&&e.setDisabled(!0),e.$c.trigger(\"tbwinit\")})},addBtnDef:function(e,t){this.btnsDef[e]=a.extend(t,this.btnsDef[e]||{})},setupUrlPrefix:function(){var e=this.o.urlProtocol;if(e)return\"string\"!=typeof e?\"https://\":e.replace(\"://\",\"\")+\"://\"},buildEditor:function(){var e=this,n=e.o.prefix,o=\"\";e.$box=a(\"<div/>\",{\"class\":n+\"box \"+n+\"editor-visible \"+n+e.o.lang+\" trumbowyg\"}),e.isTextarea=e.$ta.is(\"textarea\"),e.isTextarea?(o=e.$ta.val(),e.$ed=a(\"<div/>\"),e.$box.insertAfter(e.$ta).append(e.$ed,e.$ta)):(e.$ed=e.$ta,o=e.$ed.html(),e.$ta=a(\"<textarea/>\",{name:e.$ta.attr(\"id\"),height:e.height}).val(o),e.$box.insertAfter(e.$ed).append(e.$ta,e.$ed),e.syncCode()),e.$ta.addClass(n+\"textarea\").attr(\"tabindex\",-1),e.$ed.addClass(n+\"editor\").attr({contenteditable:!0,dir:e.lang._dir||\"ltr\"}).html(o),e.o.tabindex&&e.$ed.attr(\"tabindex\",e.o.tabindex),e.$c.is(\"[placeholder]\")&&e.$ed.attr(\"placeholder\",e.$c.attr(\"placeholder\")),e.$c.is(\"[spellcheck]\")&&e.$ed.attr(\"spellcheck\",e.$c.attr(\"spellcheck\")),e.o.resetCss&&e.$ed.addClass(n+\"reset-css\"),e.o.autogrow||e.$ta.add(e.$ed).css({height:e.height}),e.semanticCode(),e.o.autogrowOnEnter&&e.$ed.addClass(n+\"autogrow-on-enter\");var r,i=!1,s=!1,l=\"keyup\";e.$ed.on(\"dblclick\",\"img\",e.o.imgDblClickHandler).on(\"keydown\",function(t){if(!t.ctrlKey&&!t.metaKey||t.altKey){if(e.o.tabToIndent&&\"Tab\"===t.key)try{return t.shiftKey?e.execCmd(\"outdent\",!0,null):e.execCmd(\"indent\",!0,null),!1}catch(n){}}else{i=!0;var a=e.keys[String.fromCharCode(t.which).toUpperCase()];try{return e.execCmd(a.fn,a.param),!1}catch(n){}}}).on(\"compositionstart compositionupdate\",function(){s=!0}).on(l+\" compositionend\",function(t){if(\"compositionend\"===t.type)s=!1;else if(s)return;var n=t.which;if(!(n>=37&&n<=40)){if(!t.ctrlKey&&!t.metaKey||89!==n&&90!==n)if(i||17===n)\"undefined\"==typeof t.which&&e.semanticCode(!1,!1,!0);else{var a=!e.isIE||\"compositionend\"===t.type;e.semanticCode(!1,a&&13===n),e.$c.trigger(\"tbwchange\")}else e.semanticCode(!1,!0),e.$c.trigger(\"tbwchange\");setTimeout(function(){i=!1},50)}}).on(\"mouseup keydown keyup\",function(t){(!t.ctrlKey&&!t.metaKey||t.altKey)&&setTimeout(function(){i=!1},50),clearTimeout(r),r=setTimeout(function(){e.updateButtonPaneStatus()},50)}).on(\"focus blur\",function(t){if(e.$c.trigger(\"tbw\"+t.type),\"blur\"===t.type&&e.clearButtonPaneStatus(),e.o.autogrowOnEnter){if(e.autogrowOnEnterDontClose)return;\"focus\"===t.type?(e.autogrowOnEnterWasFocused=!0,e.autogrowEditorOnEnter()):e.o.autogrow||(e.$ed.css({height:e.$ed.css(\"min-height\")}),e.$c.trigger(\"tbwresize\"))}}).on(\"cut drop\",function(){setTimeout(function(){e.semanticCode(!1,!0),e.$c.trigger(\"tbwchange\")},0)}).on(\"paste\",function(n){if(e.o.removeformatPasted){n.preventDefault(),t.getSelection&&t.getSelection().deleteFromDocument&&t.getSelection().deleteFromDocument();try{var o=t.clipboardData.getData(\"Text\");try{e.doc.selection.createRange().pasteHTML(o)}catch(r){e.doc.getSelection().getRangeAt(0).insertNode(e.doc.createTextNode(o))}e.$c.trigger(\"tbwchange\",n)}catch(i){e.execCmd(\"insertText\",(n.originalEvent||n).clipboardData.getData(\"text/plain\"))}}a.each(e.pasteHandlers,function(e,t){t(n)}),setTimeout(function(){e.semanticCode(!1,!0),e.$c.trigger(\"tbwpaste\",n),e.$c.trigger(\"tbwchange\")},0)}),e.$ta.on(\"keyup\",function(){e.$c.trigger(\"tbwchange\")}).on(\"paste\",function(){setTimeout(function(){e.$c.trigger(\"tbwchange\")},0)}),a(e.doc.body).on(\"keydown\",function(t){if(27===t.which&&a(\".\"+n+\"modal-box\").length>=1)return e.closeModal(),!1})},autogrowEditorOnEnter:function(){var e=this;e.$ed.removeClass(\"autogrow-on-enter\");var t=e.$ed[0].clientHeight;e.$ed.height(\"auto\");var n=e.$ed[0].scrollHeight;e.$ed.addClass(\"autogrow-on-enter\"),t!==n&&(e.$ed.height(t),setTimeout(function(){e.$ed.css({height:n}),e.$c.trigger(\"tbwresize\")},0))},buildBtnPane:function(){var e=this,t=e.o.prefix,n=e.$btnPane=a(\"<div/>\",{\"class\":t+\"button-pane\"});a.each(e.o.btns,function(o,r){a.isArray(r)||(r=[r]);var i=a(\"<div/>\",{\"class\":t+\"button-group \"+(r.indexOf(\"fullscreen\")>=0?t+\"right\":\"\")});a.each(r,function(t,n){try{e.isSupportedBtn(n)&&i.append(e.buildBtn(n))}catch(a){}}),i.html().trim().length>0&&n.append(i)}),e.$box.prepend(n)},buildBtn:function(e){var t=this,n=t.o.prefix,o=t.btnsDef[e],r=o.dropdown,i=null==o.hasIcon||o.hasIcon,s=t.lang[e]||e,l=a(\"<button/>\",{type:\"button\",\"class\":n+e+\"-button \"+(o[\"class\"]||\"\")+(i?\"\":\" \"+n+\"textual-button\"),html:t.hasSvg&&i?'<svg><use xlink:href=\"'+t.svgPath+\"#\"+n+(o.ico||e).replace(/([A-Z]+)/g,\"-$1\").toLowerCase()+'\"/></svg>':t.hideButtonTexts?\"\":o.text||o.title||t.lang[e]||e,title:(o.title||o.text||s)+(o.key?\" (\"+(t.isMac?\"Cmd\":\"Ctrl\")+\" + \"+o.key+\")\":\"\"),tabindex:-1,mousedown:function(){return r&&!a(\".\"+e+\"-\"+n+\"dropdown\",t.$box).is(\":hidden\")||a(\"body\",t.doc).trigger(\"mousedown\"),!((t.$btnPane.hasClass(n+\"disable\")||t.$box.hasClass(n+\"disabled\"))&&!a(this).hasClass(n+\"active\")&&!a(this).hasClass(n+\"not-disable\"))&&(t.execCmd(!!r&&\"dropdown\"||o.fn||e,o.param||e,o.forceCss),!1)}});if(r){l.addClass(n+\"open-dropdown\");var d=n+\"dropdown\",c={\"class\":d+\"-\"+e+\" \"+d+\" \"+n+\"fixed-top \"+(o.dropdownClass||\"\")};c[\"data-\"+d]=e;var u=a(\"<div/>\",c);a.each(r,function(e,n){t.btnsDef[n]&&t.isSupportedBtn(n)&&u.append(t.buildSubBtn(n))}),t.$box.append(u.hide())}else o.key&&(t.keys[o.key]={fn:o.fn||e,param:o.param||e});return r||(t.tagToButton[(o.tag||e).toLowerCase()]=e),l},buildSubBtn:function(e){var t=this,n=t.o.prefix,o=t.btnsDef[e],r=null==o.hasIcon||o.hasIcon;return o.key&&(t.keys[o.key]={fn:o.fn||e,param:o.param||e}),t.tagToButton[(o.tag||e).toLowerCase()]=e,a(\"<button/>\",{type:\"button\",\"class\":n+e+\"-dropdown-button \"+(o[\"class\"]||\"\")+(o.ico?\" \"+n+o.ico+\"-button\":\"\"),html:t.hasSvg&&r?'<svg><use xlink:href=\"'+t.svgPath+\"#\"+n+(o.ico||e).replace(/([A-Z]+)/g,\"-$1\").toLowerCase()+'\"/></svg>'+(o.text||o.title||t.lang[e]||e):o.text||o.title||t.lang[e]||e,title:o.key?\"(\"+(t.isMac?\"Cmd\":\"Ctrl\")+\" + \"+o.key+\")\":null,style:o.style||null,mousedown:function(){return a(\"body\",t.doc).trigger(\"mousedown\"),t.execCmd(o.fn||e,o.param||e,o.forceCss),!1}})},isSupportedBtn:function(e){try{return this.btnsDef[e].isSupported()}catch(t){}return!0},buildOverlay:function(){var e=this;return e.$overlay=a(\"<div/>\",{\"class\":e.o.prefix+\"overlay\"}).appendTo(e.$box),e.$overlay},showOverlay:function(){var e=this;a(t).trigger(\"scroll\"),e.$overlay.fadeIn(200),e.$box.addClass(e.o.prefix+\"box-blur\")},hideOverlay:function(){var e=this;e.$overlay.fadeOut(50),e.$box.removeClass(e.o.prefix+\"box-blur\")},fixedBtnPaneEvents:function(){var e=this,n=e.o.fixedFullWidth,o=e.$box;e.o.fixedBtnPane&&(e.isFixed=!1,a(t).on(\"scroll.\"+e.eventNamespace+\" resize.\"+e.eventNamespace,function(){if(o){e.syncCode();var r=a(t).scrollTop(),i=o.offset().top+1,s=e.$btnPane,l=s.outerHeight()-2;r-i>0&&r-i-e.height<0?(e.isFixed||(e.isFixed=!0,s.css({position:\"fixed\",top:0,left:n?0:\"auto\",zIndex:7}),e.$box.css({paddingTop:s.height()})),s.css({width:n?\"100%\":o.width()-1}),a(\".\"+e.o.prefix+\"fixed-top\",o).css({position:n?\"fixed\":\"absolute\",top:n?l:l+(r-i),zIndex:15})):e.isFixed&&(e.isFixed=!1,s.removeAttr(\"style\"),e.$box.css({paddingTop:0}),a(\".\"+e.o.prefix+\"fixed-top\",o).css({position:\"absolute\",top:l}))}}))},setDisabled:function(e){var t=this,n=t.o.prefix;t.disabled=e,e?t.$ta.attr(\"disabled\",!0):t.$ta.removeAttr(\"disabled\"),t.$box.toggleClass(n+\"disabled\",e),t.$ed.attr(\"contenteditable\",!e)},destroy:function(){var e=this,n=e.o.prefix;e.isTextarea?e.$box.after(e.$ta.css({height:\"\"}).val(e.html()).removeClass(n+\"textarea\").show()):e.$box.after(e.$ed.css({height:\"\"}).removeClass(n+\"editor\").removeAttr(\"contenteditable\").removeAttr(\"dir\").html(e.html()).show()),e.$ed.off(\"dblclick\",\"img\"),e.destroyPlugins(),e.$box.remove(),e.$c.removeData(\"trumbowyg\"),a(\"body\").removeClass(n+\"body-fullscreen\"),e.$c.trigger(\"tbwclose\"),a(t).off(\"scroll.\"+e.eventNamespace+\" resize.\"+e.eventNamespace)},empty:function(){this.$ta.val(\"\"),this.syncCode(!0)},toggle:function(){var e=this,t=e.o.prefix;e.o.autogrowOnEnter&&(e.autogrowOnEnterDontClose=!e.$box.hasClass(t+\"editor-hidden\")),e.semanticCode(!1,!0),e.$c.trigger(\"tbwchange\"),setTimeout(function(){e.doc.activeElement.blur(),e.$box.toggleClass(t+\"editor-hidden \"+t+\"editor-visible\"),e.$btnPane.toggleClass(t+\"disable\"),a(\".\"+t+\"viewHTML-button\",e.$btnPane).toggleClass(t+\"active\"),e.$box.hasClass(t+\"editor-visible\")?e.$ta.attr(\"tabindex\",-1):e.$ta.removeAttr(\"tabindex\"),e.o.autogrowOnEnter&&!e.autogrowOnEnterDontClose&&e.autogrowEditorOnEnter()},0)},dropdown:function(e){var n=this,o=a(\"body\",n.doc),r=n.o.prefix,i=a(\"[data-\"+r+\"dropdown=\"+e+\"]\",n.$box),s=a(\".\"+r+e+\"-button\",n.$btnPane),l=i.is(\":hidden\");if(o.trigger(\"mousedown\"),l){var d=s.offset().left;s.addClass(r+\"active\"),i.css({position:\"absolute\",top:s.offset().top-n.$btnPane.offset().top+s.outerHeight(),left:n.o.fixedFullWidth&&n.isFixed?d:d-n.$btnPane.offset().left}).show(),a(t).trigger(\"scroll\"),o.on(\"mousedown.\"+n.eventNamespace,function(e){i.is(e.target)||(a(\".\"+r+\"dropdown\",n.$box).hide(),a(\".\"+r+\"active\",n.$btnPane).removeClass(r+\"active\"),o.off(\"mousedown.\"+n.eventNamespace))})}},html:function(e){var t=this;return null!=e?(t.$ta.val(e),t.syncCode(!0),t.$c.trigger(\"tbwchange\"),t):t.$ta.val()},syncTextarea:function(){var e=this;e.$ta.val(e.$ed.text().trim().length>0||e.$ed.find(e.o.tagsToKeep.join(\",\")).length>0?e.$ed.html():\"\")},syncCode:function(e){var t=this;if(!e&&t.$ed.is(\":visible\"))t.syncTextarea();else{var n=a(\"<div>\").html(t.$ta.val()),o=a(\"<div>\").append(n);a(t.o.tagsToRemove.join(\",\"),o).remove(),t.$ed.html(o.contents().html())}if(t.o.autogrow&&(t.height=t.$ed.height(),t.height!==t.$ta.css(\"height\")&&(t.$ta.css({height:t.height}),t.$c.trigger(\"tbwresize\"))),t.o.autogrowOnEnter){t.$ed.height(\"auto\");var r=t.autogrowOnEnterWasFocused?t.$ed[0].scrollHeight:t.$ed.css(\"min-height\");r!==t.$ta.css(\"height\")&&(t.$ed.css({height:r}),t.$c.trigger(\"tbwresize\"))}},semanticCode:function(e,t,n){var o=this;if(o.saveRange(),o.syncCode(e),o.o.semantic){if(o.semanticTag(\"b\",o.o.semanticKeepAttributes),o.semanticTag(\"i\",o.o.semanticKeepAttributes),o.semanticTag(\"s\",o.o.semanticKeepAttributes),o.semanticTag(\"strike\",o.o.semanticKeepAttributes),t){var r=o.o.inlineElementsSelector,i=\":not(\"+r+\")\";o.$ed.contents().filter(function(){return 3===this.nodeType&&this.nodeValue.trim().length>0}).wrap(\"<span data-tbw/>\");var s=function(e){if(0!==e.length){var t=e.nextUntil(i).addBack().wrapAll(\"<p/>\").parent(),n=t.nextAll(r).first();t.next(\"br\").remove(),s(n)}};s(o.$ed.children(r).first()),o.semanticTag(\"div\",!0),a(\"[data-tbw]\",o.$ed).contents().unwrap(),o.$ed.find(\"p:empty\").remove()}n||o.restoreRange(),o.syncTextarea()}},semanticTag:function(e,t){var n;if(null!=this.o.semantic&&\"object\"==typeof this.o.semantic&&this.o.semantic.hasOwnProperty(e))n=this.o.semantic[e];else{if(this.o.semantic!==!0||!this.DEFAULT_SEMANTIC_MAP.hasOwnProperty(e))return;n=this.DEFAULT_SEMANTIC_MAP[e]}a(e,this.$ed).each(function(){var e=a(this);return 0!==e.contents().length&&(e.wrap(\"<\"+n+\"/>\"),t&&a.each(e.prop(\"attributes\"),function(){e.parent().attr(this.name,this.value)}),void e.contents().unwrap())})},createLink:function(){for(var e,t,n,o=this,r=o.doc.getSelection(),i=r.getRangeAt(0),s=r.focusNode,l=(new XMLSerializer).serializeToString(i.cloneContents())||i+\"\";[\"A\",\"DIV\"].indexOf(s.nodeName)<0;)s=s.parentNode;if(s&&\"A\"===s.nodeName){var d=a(s);l=d.text(),e=d.attr(\"href\"),o.o.minimalLinks||(t=d.attr(\"title\"),n=d.attr(\"target\"));var c=o.doc.createRange();c.selectNode(s),r.removeAllRanges(),r.addRange(c)}o.saveRange();var u={url:{label:\"URL\",required:!0,value:e},text:{label:o.lang.text,value:l}};o.o.minimalLinks||a.extend(u,{title:{label:o.lang.title,value:t},target:{label:o.lang.target,value:n}}),o.openModalInsert(o.lang.createLink,u,function(e){var t=o.prependUrlPrefix(e.url);if(!t.length)return!1;var n=a(['<a href=\"',t,'\">',e.text||e.url,\"</a>\"].join(\"\"));return o.o.minimalLinks||(e.title.length>0&&n.attr(\"title\",e.title),e.target.length>0&&n.attr(\"target\",e.target)),o.range.deleteContents(),o.range.insertNode(n[0]),o.syncCode(),o.$c.trigger(\"tbwchange\"),!0})},prependUrlPrefix:function(e){var t=this;if(!t.urlPrefix)return e;var n=/^([a-z][-+.a-z0-9]*:|\\/|#)/i;if(n.test(e))return e;var a=/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;return a.test(e)?\"mailto:\"+e:t.urlPrefix+e},unlink:function(){var e=this,t=e.doc.getSelection(),n=t.focusNode;if(t.isCollapsed){for(;[\"A\",\"DIV\"].indexOf(n.nodeName)<0;)n=n.parentNode;if(n&&\"A\"===n.nodeName){var a=e.doc.createRange();a.selectNode(n),t.removeAllRanges(),t.addRange(a)}}e.execCmd(\"unlink\",void 0,void 0,!0)},insertImage:function(){var e=this;e.saveRange();var t={url:{label:\"URL\",required:!0},alt:{label:e.lang.description,value:e.getRangeText()}};e.o.imageWidthModalEdit&&(t.width={}),e.openModalInsert(e.lang.insertImage,t,function(t){e.execCmd(\"insertImage\",t.url,!1,!0);var n=a('img[src=\"'+t.url+'\"]:not([alt])',e.$box);return n.attr(\"alt\",t.alt),e.o.imageWidthModalEdit&&n.attr({width:t.width}),e.syncCode(),e.$c.trigger(\"tbwchange\"),!0})},fullscreen:function(){var e,n=this,o=n.o.prefix,r=o+\"fullscreen\",i=r+\"-placeholder\",s=n.$box.outerHeight();n.$box.toggleClass(r),e=n.$box.hasClass(r),e?n.$box.before(a(\"<div/>\",{\"class\":i}).css({height:s})):a(\".\"+i).remove(),a(\"body\").toggleClass(o+\"body-fullscreen\",e),a(t).trigger(\"scroll\"),n.$c.trigger(\"tbw\"+(e?\"open\":\"close\")+\"fullscreen\")},execCmd:function(e,t,n,a){var o=this;a=!!a||\"\",\"dropdown\"!==e&&o.$ed.focus();try{o.doc.execCommand(\"styleWithCSS\",!1,n||!1)}catch(r){}try{o[e+a](t)}catch(r){try{e(t)}catch(i){\"insertHorizontalRule\"===e?t=void 0:\"formatBlock\"===e&&o.isIE&&(t=\"<\"+t+\">\"),o.doc.execCommand(e,!1,t),o.syncCode(),o.semanticCode(!1,!0)}\"dropdown\"!==e&&(o.updateButtonPaneStatus(),o.$c.trigger(\"tbwchange\"))}},openModal:function(e,n,i){var s=this,l=s.o.prefix;if(i=i!==!1,a(\".\"+l+\"modal-box\",s.$box).length>0)return!1;s.o.autogrowOnEnter&&(s.autogrowOnEnterDontClose=!0),s.saveRange(),s.showOverlay(),s.$btnPane.addClass(l+\"disable\");var d=a(\"<div/>\",{\"class\":l+\"modal \"+l+\"fixed-top\"}).css({top:s.$box.offset().top+s.$btnPane.height(),zIndex:99999}).appendTo(a(s.doc.body));s.$overlay.one(\"click\",function(){return d.trigger(r),!1});var c;c=i?a(\"<form/>\",{action:\"\",html:n}).on(\"submit\",function(){return d.trigger(o),!1}).on(\"reset\",function(){return d.trigger(r),!1}).on(\"submit reset\",function(){s.o.autogrowOnEnter&&(s.autogrowOnEnterDontClose=!1)}):n;var u=a(\"<div/>\",{\"class\":l+\"modal-box\",html:c}).css({top:\"-\"+s.$btnPane.outerHeight(),opacity:0,paddingBottom:i?null:\"5%\"}).appendTo(d).animate({top:0,opacity:1},100);return e&&a(\"<span/>\",{text:e,\"class\":l+\"modal-title\"}).prependTo(u),i&&(a(\"input:first\",u).focus(),s.buildModalBtn(\"submit\",u),s.buildModalBtn(\"reset\",u),d.height(u.outerHeight()+10)),a(t).trigger(\"scroll\"),d},buildModalBtn:function(e,t){var n=this,o=n.o.prefix;return a(\"<button/>\",{\"class\":o+\"modal-button \"+o+\"modal-\"+e,type:e,text:n.lang[e]||e}).appendTo(a(\"form\",t))},closeModal:function(){var e=this,t=e.o.prefix;e.$btnPane.removeClass(t+\"disable\"),e.$overlay.off();var n=a(\".\"+t+\"modal-box\",a(e.doc.body));n.animate({top:\"-\"+n.height()},100,function(){n.parent().remove(),e.hideOverlay()}),e.restoreRange()},openModalInsert:function(e,t,n){var i=this,s=i.o.prefix,l=i.lang,d=\"\";return a.each(t,function(e,t){var n=t.label||e,a=t.name||e,o=t.attributes||{},r=Object.keys(o).map(function(e){return e+'=\"'+o[e]+'\"'}).join(\" \");d+='<label><input type=\"'+(t.type||\"text\")+'\" name=\"'+a+'\"'+(\"checkbox\"===t.type&&t.value?' checked=\"checked\"':' value=\"'+(t.value||\"\").replace(/\"/g,\"&quot;\"))+'\"'+r+'><span class=\"'+s+'input-infos\"><span>'+(l[n]?l[n]:n)+\"</span></span></label>\"}),i.openModal(e,d).on(o,function(){var e=a(\"form\",a(this)),r=!0,s={};a.each(t,function(t,n){var o=n.name||t,l=a('input[name=\"'+o+'\"]',e),d=l.attr(\"type\");switch(d.toLowerCase()){case\"checkbox\":s[o]=l.is(\":checked\");break;case\"radio\":s[o]=l.filter(\":checked\").val();break;default:s[o]=a.trim(l.val())}n.required&&\"\"===s[o]?(r=!1,i.addErrorOnModalField(l,i.lang.required)):n.pattern&&!n.pattern.test(s[o])&&(r=!1,i.addErrorOnModalField(l,n.patternError))}),r&&(i.restoreRange(),n(s,t)&&(i.syncCode(),i.$c.trigger(\"tbwchange\"),i.closeModal(),a(this).off(o)))}).one(r,function(){a(this).off(o),i.closeModal()})},addErrorOnModalField:function(e,t){var n=this.o.prefix,o=n+\"msg-error\",r=e.parent();e.on(\"change keyup\",function(){r.removeClass(n+\"input-error\"),setTimeout(function(){r.find(\".\"+o).remove()},150)}),r.addClass(n+\"input-error\").find(\"input+span\").append(a(\"<span/>\",{\"class\":o,text:t}))},getDefaultImgDblClickHandler:function(){var e=this;return function(){var t=a(this),n=t.attr(\"src\"),o=\"(Base64)\";0===n.indexOf(\"data:image\")&&(n=o);var r={url:{label:\"URL\",value:n,required:!0},alt:{label:e.lang.description,value:t.attr(\"alt\")}};return e.o.imageWidthModalEdit&&(r.width={value:t.attr(\"width\")?t.attr(\"width\"):\"\"}),e.openModalInsert(e.lang.insertImage,r,function(n){return n.url!==o&&t.attr({src:n.url}),t.attr({alt:n.alt}),e.o.imageWidthModalEdit&&(parseInt(n.width)>0?t.attr({width:n.width}):t.removeAttr(\"width\")),!0}),!1}},saveRange:function(){var e=this,t=e.doc.getSelection();if(e.range=null,t&&t.rangeCount){var n,a=e.range=t.getRangeAt(0),o=e.doc.createRange();o.selectNodeContents(e.$ed[0]),o.setEnd(a.startContainer,a.startOffset),n=(o+\"\").length,e.metaRange={start:n,end:n+(a+\"\").length}}},restoreRange:function(){var e,t=this,n=t.metaRange,a=t.range,o=t.doc.getSelection();if(a){if(n&&n.start!==n.end){var r,i=0,s=[t.$ed[0]],l=!1,d=!1;for(e=t.doc.createRange();!d&&(r=s.pop());)if(3===r.nodeType){var c=i+r.length;!l&&n.start>=i&&n.start<=c&&(e.setStart(r,n.start-i),l=!0),l&&n.end>=i&&n.end<=c&&(e.setEnd(r,n.end-i),d=!0),i=c}else for(var u=r.childNodes,g=u.length;g>0;)g-=1,s.push(u[g])}try{o.removeAllRanges()}catch(f){}o.addRange(e||a)}},getRangeText:function(){return this.range+\"\"},clearButtonPaneStatus:function(){var e=this,t=e.o.prefix,n=t+\"active-button \"+t+\"active\",o=t+\"original-icon\";a(\".\"+t+\"active-button\",e.$btnPane).removeClass(n),a(\".\"+o,e.$btnPane).each(function(){a(this).find(\"svg use\").attr(\"xlink:href\",a(this).data(o))})},updateButtonPaneStatus:function(){var e=this,t=e.o.prefix,n=t+\"active-button \"+t+\"active\",o=t+\"original-icon\",r=e.getTagsRecursive(e.doc.getSelection().focusNode);e.clearButtonPaneStatus(),a.each(r,function(r,i){var s=e.tagToButton[i.toLowerCase()],l=a(\".\"+t+s+\"-button\",e.$btnPane);if(l.length>0)l.addClass(n);else try{l=a(\".\"+t+\"dropdown .\"+t+s+\"-dropdown-button\",e.$box);var d=l.find(\"svg use\"),c=l.parent().data(t+\"dropdown\"),u=a(\".\"+t+c+\"-button\",e.$box),g=u.find(\"svg use\");u.addClass(n),e.o.changeActiveDropdownIcon&&d.length>0&&(u.addClass(o).data(o,g.attr(\"xlink:href\")),g.attr(\"xlink:href\",d.attr(\"xlink:href\")))}catch(f){}})},getTagsRecursive:function(e,t){var n=this;if(t=t||(e&&e.tagName?[e.tagName]:[]),!e||!e.parentNode)return t;e=e.parentNode;var o=e.tagName;return\"DIV\"===o?t:(\"P\"===o&&\"\"!==e.style.textAlign&&t.push(e.style.textAlign),a.each(n.tagHandlers,function(a,o){t=t.concat(o(e,n))}),t.push(o),n.getTagsRecursive(e,t).filter(function(e){return null!=e}))},initPlugins:function(){var e=this;e.loadedPlugins=[],a.each(a.trumbowyg.plugins,function(t,n){n.shouldInit&&!n.shouldInit(e)||(n.init(e),n.tagHandler&&e.tagHandlers.push(n.tagHandler),e.loadedPlugins.push(n))})},destroyPlugins:function(){var e=this;a.each(this.loadedPlugins,function(t,n){n.destroy&&n.destroy(e)})}}}(navigator,window,document,jQuery);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///./node_modules/trumbowyg/dist/trumbowyg.min.js?");

/***/ }),

/***/ "./node_modules/trumbowyg/dist/ui/icons.svg":
/*!**************************************************!*\
  !*** ./node_modules/trumbowyg/dist/ui/icons.svg ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"/build/images/icons.3fff0eb2.svg\";\n\n//# sourceURL=webpack:///./node_modules/trumbowyg/dist/ui/icons.svg?");

/***/ })

}]);